<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Leaderboard - SwingCity</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <style>
        /* Cycling leaderboard specific styles */
        .team-display {
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.6s ease, transform 0.6s ease;
        }
        .team-display.visible {
            opacity: 1;
            transform: translateY(0);
        }
        .cycle-indicator {
            position: fixed;
            bottom: 1.5rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            z-index: 100;
        }
        .cycle-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: rgba(255,255,255,0.2);
            transition: all 0.3s ease;
        }
        .cycle-dot.active {
            background: #4ade80;
            box-shadow: 0 0 10px #4ade80;
        }
        .no-teams-message {
            text-align: center;
            padding: 4rem 2rem;
        }
        .no-teams-message h2 {
            color: rgba(255,255,255,0.8);
            font-size: 2rem;
            margin-bottom: 1rem;
        }
        .no-teams-message p {
            color: rgba(255,255,255,0.5);
            font-size: 1.2rem;
        }
        .loading-pulse {
            animation: pulse 2s ease-in-out infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }
        .countdown-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            height: 4px;
            background: linear-gradient(90deg, #4ade80, #22c55e);
            transition: width 1s linear;
            z-index: 101;
        }
    </style>
</head>
<body class="leaderboard-body">

<div class="leaderboard-container">
    <!-- Header -->
    <div class="leaderboard-header">
        <img src="/images/swingcity-logo.png" alt="SwingCity" class="leaderboard-logo">
        <script>
        // Fullscreen toggle on 4x logo click, then 4x again to exit
        (function() {
            let logoClickCount = 0;
            let logoClickTimer = null;
            const logo = document.querySelector('.leaderboard-logo');
            if (!logo) return;
            function resetLogoClicks() {
                logoClickCount = 0;
                if (logoClickTimer) clearTimeout(logoClickTimer);
                logoClickTimer = null;
            }
            function isFullscreen() {
                return document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
            }
            function enterFullscreen() {
                const el = document.documentElement;
                if (el.requestFullscreen) el.requestFullscreen();
                else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
                else if (el.mozRequestFullScreen) el.mozRequestFullScreen();
                else if (el.msRequestFullscreen) el.msRequestFullscreen();
                document.body.classList.add('fullscreen-active');
            }
            function exitFullscreen() {
                if (document.exitFullscreen) document.exitFullscreen();
                else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
                else if (document.mozCancelFullScreen) document.mozCancelFullScreen();
                else if (document.msExitFullscreen) document.msExitFullscreen();
                document.body.classList.remove('fullscreen-active');
            }
            logo.addEventListener('click', function() {
                logoClickCount++;
                if (logoClickTimer) clearTimeout(logoClickTimer);
                logoClickTimer = setTimeout(resetLogoClicks, 2000);
                if (logoClickCount === 4) {
                    if (!isFullscreen()) {
                        enterFullscreen();
                    } else {
                        exitFullscreen();
                    }
                    logoClickCount = 0;
                }
            });
            document.addEventListener('fullscreenchange', function() {
                if (!isFullscreen()) document.body.classList.remove('fullscreen-active');
            });
        })();
        </script>
    </div>

    <!-- Loading State -->
    <div class="leaderboard-state active" id="loadingState">
        <div class="loading-container">
            <div class="spinner"></div>
            <h2 class="loading-pulse">Loading Leaderboard...</h2>
        </div>
    </div>

    <!-- No Teams State -->
    <div class="leaderboard-state" id="noTeamsState">
        <div class="no-teams-message">
            <div style="font-size: 4rem; margin-bottom: 1rem;">üèåÔ∏è</div>
            <h2>No Active Teams</h2>
            <p>Waiting for teams to start playing...</p>
        </div>
    </div>

    <!-- Team Scores Display -->
    <div class="leaderboard-state" id="scoresState">
        <div class="team-display" id="teamDisplay">
            <div class="scores-container">
                <div class="players-grid" id="playersGrid">
                    <!-- Players will be populated by JavaScript -->
                </div>
            </div>
        </div>
    </div>

    <!-- Cycle Indicator -->
    <div class="cycle-indicator" id="cycleIndicator"></div>
    
    <!-- Countdown bar for scanned team -->
    <div class="countdown-bar" id="countdownBar" style="width: 0%;"></div>
</div>

<!-- Hidden RFID input to capture keyboard scanner input -->
<input type="text" id="hiddenRfidInput" style="position: absolute; left: -9999px; opacity: 0;" tabindex="-1">

<script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
<script>
// Global variables
let allTeams = [];
let teamScores = [];
let currentTeamIndex = 0;
let cycleInterval = null;
let socket = null;
let scanTimeout = null;

// Scanned team state
let scannedTeamData = null;
let scannedTeamTimeout = null;
let countdownInterval = null;
let countdownRemaining = 0;

// Configuration
const CYCLE_DURATION = 8000; // 8 seconds per team in cycling mode
const SCANNED_DISPLAY_DURATION = 60000; // 60 seconds for scanned team
const REFRESH_INTERVAL = 60000; // Refresh team list every 60 seconds

// Hole ID to display name mapping
const HOLE_NAMES = {
    'Plinko': 'Plinko',
    'SpinningTop': 'Spinning Top', 
    'Haphazard': 'Haphazard',
    'Roundhouse': 'Roundhouse',
    'HillHop': 'Hill Hop',
    'SkiJump': 'Ski Jump',
    'Mastermind': 'Mastermind',
    'Igloo': 'Igloo',
    'Octagon': 'Octagon',
    'LoopDeLoop': 'Loop De Loop',
    'UpAndOver': 'Up And Over',
    'Lopsided': 'Lopsided',
    'Lopside': 'Lopside'
};

// Initialize the leaderboard
document.addEventListener('DOMContentLoaded', function() {
    initializeSocket();
    setupRFIDCapture();
    loadAllTeams();
    
    // Periodically refresh team list
    setInterval(loadAllTeams, REFRESH_INTERVAL);
});

function initializeSocket() {
    socket = io();
    
    socket.on('connect', function() {
        console.log('Leaderboard connected to server');
    });
    
    socket.on('disconnect', function() {
        console.log('Leaderboard disconnected from server');
    });
    
    // Listen for score updates to refresh display
    socket.on('scoreUpdate', function() {
        loadAllTeams();
    });
}

function setupRFIDCapture() {
    const hiddenInput = document.getElementById('hiddenRfidInput');

    // Keep focus on hidden input to capture RFID scanner output
    hiddenInput.focus();

    // Refocus if user clicks elsewhere
    document.addEventListener('click', function() {
        setTimeout(() => hiddenInput.focus(), 100);
    });

    // Handle RFID input
    hiddenInput.addEventListener('input', function(e) {
        const value = e.target.value.trim();

        // Clear any existing timeout
        if (scanTimeout) {
            clearTimeout(scanTimeout);
        }

        // Set timeout to process the input (RFID scanners typically send all data quickly)
        scanTimeout = setTimeout(() => {
            if (value.length >= 8) { // Minimum RFID length
                processRFIDScan(value);
                hiddenInput.value = ''; // Clear input
            }
        }, 100);
    });

    // Handle Enter key (some RFID scanners append this)
    hiddenInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            const value = e.target.value.trim();
            if (value.length >= 8) {
                processRFIDScan(value);
                hiddenInput.value = '';
            }
        }
    });
}

function processRFIDScan(rfid) {
    console.log('RFID Scanned:', rfid);
    
    // Fetch team data for the scanned card
    fetch(`/api/team/${rfid}`)
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            return response.json();
        })
        .then(teamData => {
            displayScannedTeam(teamData);
        })
        .catch(error => {
            console.error('Error fetching team data:', error);
            // Continue cycling if team not found
        });
}

function displayScannedTeam(teamData) {
    // Stop cycling
    stopCycling();
    
    // Clear any existing scanned team timeout
    if (scannedTeamTimeout) {
        clearTimeout(scannedTeamTimeout);
    }
    if (countdownInterval) {
        clearInterval(countdownInterval);
    }
    
    // Store scanned team data
    scannedTeamData = teamData;
    
    // Hide cycle indicator, show countdown bar
    document.getElementById('cycleIndicator').style.display = 'none';
    
    // Display the team
    displayTeam(teamData, true);
    showState('scores');
    
    // Start countdown bar
    countdownRemaining = SCANNED_DISPLAY_DURATION;
    updateCountdownBar();
    countdownInterval = setInterval(() => {
        countdownRemaining -= 1000;
        updateCountdownBar();
        if (countdownRemaining <= 0) {
            clearInterval(countdownInterval);
        }
    }, 1000);
    
    // Set timeout to resume cycling
    scannedTeamTimeout = setTimeout(() => {
        scannedTeamData = null;
        document.getElementById('countdownBar').style.width = '0%';
        document.getElementById('cycleIndicator').style.display = 'flex';
        
        // Resume cycling
        if (teamScores.length > 0) {
            startCycling();
            displayCurrentTeam();
        }
    }, SCANNED_DISPLAY_DURATION);
}

function updateCountdownBar() {
    const percentage = (countdownRemaining / SCANNED_DISPLAY_DURATION) * 100;
    document.getElementById('countdownBar').style.width = percentage + '%';
}

async function loadAllTeams() {
    try {
        // Don't show loading if we're displaying a scanned team
        if (!scannedTeamData) {
            showState('loading');
        }
        
        // Fetch all teams
        const teamsResponse = await fetch('/api/teams');
        if (!teamsResponse.ok) throw new Error('Failed to fetch teams');
        const teamsData = await teamsResponse.json();
        
        allTeams = teamsData.teams || [];
        
        if (allTeams.length === 0) {
            if (!scannedTeamData) {
                showState('noTeams');
                stopCycling();
            }
            return;
        }
        
        // Fetch scores for each team
        teamScores = [];
        for (const team of allTeams) {
            try {
                const scoreResponse = await fetch(`/api/team/${team.rfid}`);
                if (scoreResponse.ok) {
                    const scoreData = await scoreResponse.json();
                    teamScores.push(scoreData);
                }
            } catch (err) {
                console.warn(`Failed to fetch scores for team ${team.rfid}:`, err);
            }
        }
        
        // Filter out teams with no score data
        teamScores = teamScores.filter(t => t && t.players && t.players.length > 0);
        
        if (teamScores.length === 0) {
            if (!scannedTeamData) {
                showState('noTeams');
                stopCycling();
            }
            return;
        }
        
        // Sort by total score (highest first)
        teamScores.sort((a, b) => (b.totalScore || 0) - (a.totalScore || 0));
        
        // Update cycle indicator dots
        updateCycleIndicator();
        
        // Only start cycling if not showing a scanned team
        if (!scannedTeamData) {
            if (!cycleInterval) {
                currentTeamIndex = 0;
                displayCurrentTeam();
                startCycling();
            }
            showState('scores');
        }
        
    } catch (error) {
        console.error('Error loading teams:', error);
        if (!scannedTeamData) {
            showState('noTeams');
        }
    }
}

function updateCycleIndicator() {
    const indicator = document.getElementById('cycleIndicator');
    indicator.innerHTML = '';
    
    // Only show dots if more than one team and not showing scanned team
    if (teamScores.length <= 1 || scannedTeamData) return;
    
    teamScores.forEach((_, index) => {
        const dot = document.createElement('div');
        dot.className = 'cycle-dot' + (index === currentTeamIndex ? ' active' : '');
        indicator.appendChild(dot);
    });
}

function displayCurrentTeam() {
    if (teamScores.length === 0) return;
    
    const teamData = teamScores[currentTeamIndex];
    displayTeam(teamData, false);
    
    // Update cycle indicator
    document.querySelectorAll('.cycle-dot').forEach((dot, index) => {
        dot.classList.toggle('active', index === currentTeamIndex);
    });
}

function displayTeam(teamData, isScanned) {
    const teamDisplay = document.getElementById('teamDisplay');
    
    // Fade out
    teamDisplay.classList.remove('visible');
    
    setTimeout(() => {
        // Create scorecard table
        const playersGrid = document.getElementById('playersGrid');
        playersGrid.innerHTML = '';
        
        if (teamData.players && teamData.players.length > 0) {
            const scorecardTable = createScorecardTable(teamData.players);
            playersGrid.appendChild(scorecardTable);
        }
        
        // Fade in
        teamDisplay.classList.add('visible');
    }, 300);
}

function startCycling() {
    if (cycleInterval) clearInterval(cycleInterval);
    
    cycleInterval = setInterval(() => {
        if (teamScores.length <= 1 || scannedTeamData) return;
        
        currentTeamIndex = (currentTeamIndex + 1) % teamScores.length;
        displayCurrentTeam();
    }, CYCLE_DURATION);
}

function stopCycling() {
    if (cycleInterval) {
        clearInterval(cycleInterval);
        cycleInterval = null;
    }
}

function createScorecardTable(players) {
    const table = document.createElement('table');
    table.className = 'scorecard-table';
    table.setAttribute('role', 'table');

    const caption = document.createElement('caption');
    caption.className = 'visually-hidden';
    caption.textContent = 'Per-player hole scores and totals';
    table.appendChild(caption);
    
    const holeOrder = ['Plinko', 'SpinningTop', 'Haphazard', 'Roundhouse', 'HillHop', 'SkiJump', 'Mastermind', 'Igloo', 'Octagon', 'LoopDeLoop', 'UpAndOver', 'Lopside'];
    
    // Create header
    const thead = document.createElement('thead');
    const headerRow = document.createElement('tr');
    
    const playerHeader = document.createElement('th');
    playerHeader.className = 'player-name-header';
    playerHeader.textContent = 'Player';
    headerRow.appendChild(playerHeader);
    
    holeOrder.forEach((holeId) => {
        const holeName = HOLE_NAMES[holeId] || holeId;
        const th = document.createElement('th');
        th.className = 'hole-header';
        const span = document.createElement('span');
        span.textContent = holeName;
        th.appendChild(span);
        headerRow.appendChild(th);
    });
    
    const totalHeader = document.createElement('th');
    totalHeader.className = 'total-header';
    totalHeader.textContent = 'Total';
    headerRow.appendChild(totalHeader);
    
    thead.appendChild(headerRow);
    table.appendChild(thead);
    
    // Create body rows
    const tbody = document.createElement('tbody');
    players.forEach(player => {
        const playerTotal = Object.values(player.scores || {}).reduce((sum, holeScore) => {
            return sum + (holeScore.total || 0);
        }, 0);
        
        const row = document.createElement('tr');
        
        const nameCell = document.createElement('th');
        nameCell.className = 'player-name-cell';
        nameCell.setAttribute('scope', 'row');
        nameCell.textContent = player.name;
        row.appendChild(nameCell);
        
        holeOrder.forEach(holeId => {
            const score = player.scores ? player.scores[holeId] : null;
            const scoreValue = score ? score.total : '-';
            const scoreClass = score ? (score.total > 0 ? 'positive-score' : score.total < 0 ? 'negative-score' : 'zero-score') : 'no-score';

            const scoreCell = document.createElement('td');
            scoreCell.className = `score-cell ${scoreClass}`;
            scoreCell.textContent = scoreValue;
            scoreCell.dataset.holeId = holeId;
            row.appendChild(scoreCell);
        });
        
        const totalClass = playerTotal > 0 ? 'positive-score' : playerTotal < 0 ? 'negative-score' : 'zero-score';
        const totalCell = document.createElement('td');
        totalCell.className = `total-cell ${totalClass}`;
        totalCell.textContent = playerTotal;
        row.appendChild(totalCell);
        
        tbody.appendChild(row);
    });
    
    table.appendChild(tbody);

    // Highlight best/worst per column
    try {
        const bodyRows = Array.from(tbody.querySelectorAll('tr'));
        const holeCount = holeOrder.length;
        for (let colIndex = 0; colIndex < holeCount; colIndex++) {
            let values = [];
            bodyRows.forEach(r => {
                const cell = r.querySelectorAll('td,th')[colIndex+1];
                if (!cell || cell.classList.contains('total-cell')) return;
                const raw = cell.textContent.trim();
                const num = parseInt(raw, 10);
                if (!isNaN(num)) {
                    values.push({ num, cell });
                }
            });
            if (values.length) {
                const max = Math.max(...values.map(v => v.num));
                const min = Math.min(...values.map(v => v.num));
                values.forEach(v => {
                    if (v.num === max && max > 0) v.cell.classList.add('best-score');
                    if (v.num === min && min < 0) v.cell.classList.add('worst-score');
                });
            }
        }
    } catch (e) {
        console.warn('Highlighting failed', e);
    }
    
    return table;
}

function showState(stateName) {
    document.querySelectorAll('.leaderboard-state').forEach(state => {
        state.classList.remove('active');
    });
    
    const stateElement = document.getElementById(stateName + 'State');
    if (stateElement) {
        stateElement.classList.add('active');
    }
    
    // Ensure hidden input stays focused for RFID capture
    setTimeout(() => {
        document.getElementById('hiddenRfidInput').focus();
    }, 100);
}
</script>

</body>
</html>
