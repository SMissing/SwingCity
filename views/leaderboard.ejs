<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Leaderboard - SwingCity</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <style>
        /* Prevent page scrolling - this is for TV display */
        html, body {
            overflow: hidden !important;
            height: 100vh !important;
            max-height: 100vh !important;
        }
        .leaderboard-body {
            overflow: hidden !important;
        }
        .leaderboard-container {
            height: 100vh;
            max-height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        .leaderboard-state {
            flex: 1;
            overflow: hidden;
        }

        /* Cycling leaderboard specific styles */
        .team-display {
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.6s ease, transform 0.6s ease;
        }
        .team-display.visible {
            opacity: 1;
            transform: translateY(0);
        }
        .cycle-indicator {
            position: fixed;
            bottom: 1.5rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            z-index: 100;
        }
        .cycle-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: rgba(255,255,255,0.2);
            transition: all 0.3s ease;
        }
        .cycle-dot.active {
            background: #4ade80;
            box-shadow: 0 0 10px #4ade80;
        }
        .no-teams-message {
            text-align: center;
            padding: 4rem 2rem;
        }
        .no-teams-message h2 {
            color: rgba(255,255,255,0.8);
            font-size: 2rem;
            margin-bottom: 1rem;
        }
        .no-teams-message p {
            color: rgba(255,255,255,0.5);
            font-size: 1.2rem;
        }
        .loading-pulse {
            animation: pulse 2s ease-in-out infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }
        .countdown-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            height: 4px;
            background: linear-gradient(90deg, #4ade80, #22c55e);
            transition: width 1s linear;
            z-index: 101;
        }

        /* High Score Board Styles */
        #highScoresState {
            position: absolute;
            top: 250px; /* Below the logo header */
            left: 0;
            right: 0;
            bottom: 50px; /* Above the cycle indicators */
            display: flex;
            align-items: flex-start;
            justify-content: center;
            padding: 1rem 2rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        #highScoresState.active {
            pointer-events: auto;
            opacity: 1;
        }
        .highscore-display {
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.6s ease, transform 0.6s ease;
            width: 100%;
            max-width: 1200px;
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        .highscore-display.visible {
            opacity: 1;
            transform: translateY(0);
        }
        .highscore-table-container {
            background: rgba(0,0,0,0.6);
            border-radius: 16px;
            padding: 0;
            border: 2px solid rgba(255,215,0,0.4);
            box-shadow: 0 8px 32px rgba(0,0,0,0.4), 0 0 60px rgba(255,215,0,0.1);
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: relative;
        }
        .highscore-table-scroll {
            height: 100%;
            overflow-y: auto;
            scroll-behavior: smooth;
        }
        .highscore-table-scroll::-webkit-scrollbar {
            width: 8px;
        }
        .highscore-table-scroll::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
        }
        .highscore-table-scroll::-webkit-scrollbar-thumb {
            background: rgba(255,215,0,0.5);
            border-radius: 4px;
        }
        .highscore-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            font-size: 1.4rem;
        }
        .highscore-table thead {
            position: sticky;
            top: 0;
            z-index: 10;
        }
        .highscore-table thead th {
            padding: 1.2rem 1.5rem;
            text-align: left;
            font-weight: 700;
            color: #ffd700;
            background: #1a1a1a;
            border-bottom: 3px solid rgba(255,215,0,0.5);
            text-transform: uppercase;
            letter-spacing: 0.08em;
            font-size: 1.2rem;
        }
        .highscore-table .rank-header { width: 120px; text-align: center; }
        .highscore-table .name-header { text-align: left; }
        .highscore-table .score-header { width: 180px; text-align: right; }
        .highscore-table tbody tr {
            transition: all 0.2s ease;
            border-bottom: 1px solid rgba(255,215,0,0.1);
        }
        .highscore-table tbody tr:hover {
            background: rgba(255,215,0,0.08);
        }
        .highscore-table tbody td {
            padding: 1rem 1.5rem;
            color: rgba(255,255,255,0.95);
            border-bottom: 1px solid rgba(255,215,0,0.1);
        }
        .highscore-table .rank-cell {
            text-align: center;
            font-weight: 700;
            font-size: 1.6rem;
        }
        .highscore-table .rank-1 { color: #ffd700; text-shadow: 0 0 15px rgba(255,215,0,0.6); }
        .highscore-table .rank-2 { color: #e0e0e0; text-shadow: 0 0 12px rgba(224,224,224,0.5); }
        .highscore-table .rank-3 { color: #cd7f32; text-shadow: 0 0 12px rgba(205,127,50,0.5); }
        .highscore-table .name-cell {
            font-weight: 500;
            font-size: 1.5rem;
        }
        .highscore-table .score-cell {
            text-align: right;
            font-weight: 700;
            font-size: 1.6rem;
            color: #4ade80;
        }
        .highscore-table tbody tr.top-3 {
            background: linear-gradient(90deg, rgba(255,215,0,0.12) 0%, transparent 100%);
        }
        .highscore-table tbody tr.rank-1-row {
            background: linear-gradient(90deg, rgba(255,215,0,0.2) 0%, rgba(255,215,0,0.05) 100%);
        }
        .highscore-empty {
            text-align: center;
            padding: 3rem;
            color: rgba(255,255,255,0.5);
            font-size: 1.2rem;
        }

        /* Cycle indicator for high score mode */
        .cycle-dot.highscore-dot {
            background: rgba(255,215,0,0.3);
        }
        .cycle-dot.highscore-dot.active {
            background: #ffd700;
            box-shadow: 0 0 10px #ffd700;
        }
    </style>
</head>
<body class="leaderboard-body">

<div class="leaderboard-container">
    <!-- Header -->
    <div class="leaderboard-header">
        <img src="/images/swingcity-logo.png" alt="SwingCity" class="leaderboard-logo">
        <script>
        // Fullscreen toggle on 4x logo click, then 4x again to exit
        (function() {
            let logoClickCount = 0;
            let logoClickTimer = null;
            const logo = document.querySelector('.leaderboard-logo');
            if (!logo) return;
            function resetLogoClicks() {
                logoClickCount = 0;
                if (logoClickTimer) clearTimeout(logoClickTimer);
                logoClickTimer = null;
            }
            function isFullscreen() {
                return document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
            }
            function enterFullscreen() {
                const el = document.documentElement;
                if (el.requestFullscreen) el.requestFullscreen();
                else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
                else if (el.mozRequestFullScreen) el.mozRequestFullScreen();
                else if (el.msRequestFullscreen) el.msRequestFullscreen();
                document.body.classList.add('fullscreen-active');
            }
            function exitFullscreen() {
                if (document.exitFullscreen) document.exitFullscreen();
                else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
                else if (document.mozCancelFullScreen) document.mozCancelFullScreen();
                else if (document.msExitFullscreen) document.msExitFullscreen();
                document.body.classList.remove('fullscreen-active');
            }
            logo.addEventListener('click', function() {
                logoClickCount++;
                if (logoClickTimer) clearTimeout(logoClickTimer);
                logoClickTimer = setTimeout(resetLogoClicks, 2000);
                if (logoClickCount === 4) {
                    if (!isFullscreen()) {
                        enterFullscreen();
                    } else {
                        exitFullscreen();
                    }
                    logoClickCount = 0;
                }
            });
            document.addEventListener('fullscreenchange', function() {
                if (!isFullscreen()) document.body.classList.remove('fullscreen-active');
            });
        })();
        </script>
    </div>

    <!-- Loading State -->
    <div class="leaderboard-state active" id="loadingState">
        <div class="loading-container">
            <div class="spinner"></div>
            <h2 class="loading-pulse">Loading Leaderboard...</h2>
        </div>
    </div>

    <!-- No Teams State -->
    <div class="leaderboard-state" id="noTeamsState">
        <div class="no-teams-message">
            <div style="font-size: 4rem; margin-bottom: 1rem;">üèåÔ∏è</div>
            <h2>No Active Teams</h2>
            <p>Waiting for teams to start playing...</p>
        </div>
    </div>

    <!-- Team Scores Display -->
    <div class="leaderboard-state" id="scoresState">
        <div class="team-display" id="teamDisplay">
            <div class="scores-container">
                <div class="players-grid" id="playersGrid">
                    <!-- Players will be populated by JavaScript -->
                </div>
            </div>
        </div>
    </div>

    <!-- High Scores Display -->
    <div class="leaderboard-state" id="highScoresState">
        <div class="highscore-display" id="highScoreDisplay">
            <div class="highscore-table-container">
                <div class="highscore-table-scroll" id="highScoreScroll">
                    <table class="highscore-table" id="highScoreTable">
                        <thead>
                            <tr>
                                <th class="rank-header">Rank</th>
                                <th class="name-header">Player</th>
                                <th class="score-header">Score</th>
                            </tr>
                        </thead>
                        <tbody id="highScoreBody">
                            <!-- High scores will be populated by JavaScript -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <!-- Cycle Indicator -->
    <div class="cycle-indicator" id="cycleIndicator"></div>
    
    <!-- Countdown bar for scanned team -->
    <div class="countdown-bar" id="countdownBar" style="width: 0%;"></div>
</div>

<!-- Hidden RFID input to capture keyboard scanner input -->
<input type="text" id="hiddenRfidInput" style="position: absolute; left: -9999px; opacity: 0;" tabindex="-1">

<script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
<script>
// Global variables
let allTeams = [];
let teamScores = [];
let highScores = [];
let currentTeamIndex = 0;
let currentDisplayMode = 'team'; // 'team' or 'highscore'
let cycleInterval = null;
let socket = null;
let scanTimeout = null;

// Scanned team state
let scannedTeamData = null;
let scannedTeamTimeout = null;
let countdownInterval = null;
let countdownRemaining = 0;

// Configuration
const CYCLE_DURATION = 8000; // 8 seconds per team in cycling mode
const HIGHSCORE_TOP_WAIT = 5000; // 5 seconds wait at top of high scores
const HIGHSCORE_BOTTOM_WAIT = 2000; // 2 seconds wait at bottom of high scores
const HIGHSCORE_SCROLL_SPEED = 50; // pixels per second for scrolling
const SCANNED_DISPLAY_DURATION = 60000; // 60 seconds for scanned team
const REFRESH_INTERVAL = 60000; // Refresh team list every 60 seconds

// High score scroll state
let highScoreScrollInterval = null;
let highScoreScrollTimeout = null;

// Hole ID to display name mapping
const HOLE_NAMES = {
    'Plinko': 'Plinko',
    'SpinningTop': 'Spinning Top', 
    'Haphazard': 'Haphazard',
    'Roundhouse': 'Roundhouse',
    'HillHop': 'Hill Hop',
    'SkiJump': 'Ski Jump',
    'Mastermind': 'Mastermind',
    'Igloo': 'Igloo',
    'Octagon': 'Octagon',
    'LoopDeLoop': 'Loop De Loop',
    'UpAndOver': 'Up And Over',
    'Lopsided': 'Lopsided',
    'Lopside': 'Lopside'
};

// Initialize the leaderboard
document.addEventListener('DOMContentLoaded', function() {
    initializeSocket();
    setupRFIDCapture();
    loadAllData();
    
    // Periodically refresh all data
    setInterval(loadAllData, REFRESH_INTERVAL);
});

// Load both teams and high scores
async function loadAllData() {
    await Promise.all([loadAllTeams(), loadHighScores()]);
}

function initializeSocket() {
    socket = io();
    
    socket.on('connect', function() {
        console.log('Leaderboard connected to server');
    });
    
    socket.on('disconnect', function() {
        console.log('Leaderboard disconnected from server');
    });
    
    // Listen for score updates to refresh display
    socket.on('scoreUpdate', function() {
        loadAllTeams();
    });
    
    // Listen for high score updates to refresh high scores
    socket.on('highScoreUpdated', function(data) {
        console.log('üèÜ High score updated!', data);
        loadHighScores();
    });
}

function setupRFIDCapture() {
    const hiddenInput = document.getElementById('hiddenRfidInput');

    // Keep focus on hidden input to capture RFID scanner output
    hiddenInput.focus();

    // Refocus if user clicks elsewhere
    document.addEventListener('click', function() {
        setTimeout(() => hiddenInput.focus(), 100);
    });

    // Handle RFID input
    hiddenInput.addEventListener('input', function(e) {
        const value = e.target.value.trim();

        // Clear any existing timeout
        if (scanTimeout) {
            clearTimeout(scanTimeout);
        }

        // Set timeout to process the input (RFID scanners typically send all data quickly)
        scanTimeout = setTimeout(() => {
            if (value.length >= 8) { // Minimum RFID length
                processRFIDScan(value);
                hiddenInput.value = ''; // Clear input
            }
        }, 100);
    });

    // Handle Enter key (some RFID scanners append this)
    hiddenInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            const value = e.target.value.trim();
            if (value.length >= 8) {
                processRFIDScan(value);
                hiddenInput.value = '';
            }
        }
    });
}

function processRFIDScan(rfid) {
    console.log('RFID Scanned:', rfid);
    
    // Fetch team data for the scanned card
    fetch(`/api/team/${rfid}`)
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            return response.json();
        })
        .then(teamData => {
            displayScannedTeam(teamData);
        })
        .catch(error => {
            console.error('Error fetching team data:', error);
            // Continue cycling if team not found
        });
}

function displayScannedTeam(teamData) {
    // Stop cycling
    stopCycling();
    
    // Clear any existing scanned team timeout
    if (scannedTeamTimeout) {
        clearTimeout(scannedTeamTimeout);
    }
    if (countdownInterval) {
        clearInterval(countdownInterval);
    }
    
    // Store scanned team data
    scannedTeamData = teamData;
    
    // Hide cycle indicator, show countdown bar
    document.getElementById('cycleIndicator').style.display = 'none';
    
    // Display the team
    displayTeam(teamData, true);
    showState('scores');
    
    // Start countdown bar
    countdownRemaining = SCANNED_DISPLAY_DURATION;
    updateCountdownBar();
    countdownInterval = setInterval(() => {
        countdownRemaining -= 1000;
        updateCountdownBar();
        if (countdownRemaining <= 0) {
            clearInterval(countdownInterval);
        }
    }, 1000);
    
    // Set timeout to resume cycling
    scannedTeamTimeout = setTimeout(() => {
        resumeCycling();
    }, SCANNED_DISPLAY_DURATION);
}

function updateCountdownBar() {
    const percentage = (countdownRemaining / SCANNED_DISPLAY_DURATION) * 100;
    document.getElementById('countdownBar').style.width = percentage + '%';
}

async function loadAllTeams() {
    try {
        // Don't show loading if we're displaying a scanned team
        if (!scannedTeamData) {
            showState('loading');
        }
        
        // Fetch all teams
        const teamsResponse = await fetch('/api/teams');
        if (!teamsResponse.ok) throw new Error('Failed to fetch teams');
        const teamsData = await teamsResponse.json();
        
        allTeams = teamsData.teams || [];
        
        if (allTeams.length === 0) {
            if (!scannedTeamData) {
                showState('noTeams');
                stopCycling();
            }
            return;
        }
        
        // Fetch scores for each team
        teamScores = [];
        for (const team of allTeams) {
            try {
                const scoreResponse = await fetch(`/api/team/${team.rfid}`);
                if (scoreResponse.ok) {
                    const scoreData = await scoreResponse.json();
                    teamScores.push(scoreData);
                }
            } catch (err) {
                console.warn(`Failed to fetch scores for team ${team.rfid}:`, err);
            }
        }
        
        // Filter out teams with no score data
        teamScores = teamScores.filter(t => t && t.players && t.players.length > 0);
        
        if (teamScores.length === 0) {
            if (!scannedTeamData) {
                showState('noTeams');
                stopCycling();
            }
            return;
        }
        
        // Sort by total score (highest first)
        teamScores.sort((a, b) => (b.totalScore || 0) - (a.totalScore || 0));
        
        // Update cycle indicator dots
        updateCycleIndicator();
        
        // Only start cycling if not showing a scanned team
        if (!scannedTeamData) {
            if (!cycleInterval) {
                currentTeamIndex = 0;
                currentDisplayMode = 'team';
                displayCurrentTeam();
                startCycling();
            }
        }
        
    } catch (error) {
        console.error('Error loading teams:', error);
        if (!scannedTeamData) {
            showState('noTeams');
        }
    }
}

// Load high scores from API
async function loadHighScores() {
    try {
        const response = await fetch('/api/highscores?limit=25');
        if (!response.ok) throw new Error('Failed to fetch high scores');
        const data = await response.json();
        highScores = data.highScores || [];
        console.log(`Loaded ${highScores.length} high scores`);
    } catch (error) {
        console.error('Error loading high scores:', error);
        highScores = [];
    }
}

function updateCycleIndicator() {
    const indicator = document.getElementById('cycleIndicator');
    indicator.innerHTML = '';
    
    // Don't show if scanned team is displayed
    if (scannedTeamData) return;
    
    // Calculate total items (teams + high score displays after each team)
    const totalItems = teamScores.length * 2; // Each team followed by high scores
    
    if (totalItems <= 2) return; // Need more than one cycle item
    
    for (let i = 0; i < totalItems; i++) {
        const dot = document.createElement('div');
        const isHighScoreDot = i % 2 === 1; // Odd indices are high score displays
        const isActive = (i === currentTeamIndex * 2 && currentDisplayMode === 'team') ||
                        (i === currentTeamIndex * 2 + 1 && currentDisplayMode === 'highscore');
        
        dot.className = 'cycle-dot' + (isHighScoreDot ? ' highscore-dot' : '') + (isActive ? ' active' : '');
        indicator.appendChild(dot);
    }
}

function displayCurrentTeam() {
    if (teamScores.length === 0) return;
    
    const teamData = teamScores[currentTeamIndex];
    displayTeam(teamData, false);
    showState('scores');
    currentDisplayMode = 'team';
    
    // Update cycle indicator
    updateCycleIndicator();
}

function displayHighScores() {
    showState('highScores');
    currentDisplayMode = 'highscore';
    
    // Clear any existing scroll timers
    clearHighScoreScrollTimers();
    
    const highScoreDisplay = document.getElementById('highScoreDisplay');
    const highScoreBody = document.getElementById('highScoreBody');
    const scrollContainer = document.getElementById('highScoreScroll');
    
    // Fade out first
    highScoreDisplay.classList.remove('visible');
    
    setTimeout(() => {
        // Clear existing content
        highScoreBody.innerHTML = '';
        
        // Reset scroll position to top
        if (scrollContainer) {
            scrollContainer.scrollTop = 0;
        }
        
        if (highScores.length === 0) {
            // Show empty state
            highScoreBody.innerHTML = `
                <tr>
                    <td colspan="3" class="highscore-empty">
                        <div>No scores yet</div>
                    </td>
                </tr>
            `;
        } else {
            // Populate high scores
            highScores.forEach((score, index) => {
                const rank = index + 1;
                const row = document.createElement('tr');
                
                // Add special classes for top 3
                if (rank <= 3) row.classList.add('top-3');
                if (rank === 1) row.classList.add('rank-1-row');
                
                // Get rank display (medal for top 3)
                let rankDisplay = rank;
                if (rank === 1) rankDisplay = 'ü•á';
                else if (rank === 2) rankDisplay = 'ü•à';
                else if (rank === 3) rankDisplay = 'ü•â';
                
                row.innerHTML = `
                    <td class="rank-cell rank-${rank}">${rankDisplay}</td>
                    <td class="name-cell">${escapeHtml(score.playerName)}</td>
                    <td class="score-cell">${score.totalScore.toLocaleString()}</td>
                `;
                
                highScoreBody.appendChild(row);
            });
        }
        
        // Fade in
        highScoreDisplay.classList.add('visible');
        
        // Start auto-scroll after showing
        setTimeout(() => {
            startHighScoreAutoScroll();
        }, 300);
    }, 300);
    
    // Update cycle indicator
    updateCycleIndicator();
}

function clearHighScoreScrollTimers() {
    if (highScoreScrollInterval) {
        clearInterval(highScoreScrollInterval);
        highScoreScrollInterval = null;
    }
    if (highScoreScrollTimeout) {
        clearTimeout(highScoreScrollTimeout);
        highScoreScrollTimeout = null;
    }
}

function startHighScoreAutoScroll() {
    const scrollContainer = document.getElementById('highScoreScroll');
    if (!scrollContainer) return;
    
    const scrollHeight = scrollContainer.scrollHeight;
    const clientHeight = scrollContainer.clientHeight;
    const maxScroll = scrollHeight - clientHeight;
    
    // If content fits without scrolling, just wait and move on
    if (maxScroll <= 0) {
        highScoreScrollTimeout = setTimeout(() => {
            onHighScoreScrollComplete();
        }, HIGHSCORE_TOP_WAIT + HIGHSCORE_BOTTOM_WAIT);
        return;
    }
    
    // Wait at top for 5 seconds
    highScoreScrollTimeout = setTimeout(() => {
        // Calculate scroll duration based on distance and speed
        const scrollDuration = (maxScroll / HIGHSCORE_SCROLL_SPEED) * 1000;
        const scrollStep = maxScroll / (scrollDuration / 16); // 60fps
        
        let currentScroll = 0;
        
        // Start smooth scrolling
        highScoreScrollInterval = setInterval(() => {
            currentScroll += scrollStep;
            
            if (currentScroll >= maxScroll) {
                scrollContainer.scrollTop = maxScroll;
                clearInterval(highScoreScrollInterval);
                highScoreScrollInterval = null;
                
                // Wait at bottom for 2 seconds, then move to next
                highScoreScrollTimeout = setTimeout(() => {
                    onHighScoreScrollComplete();
                }, HIGHSCORE_BOTTOM_WAIT);
            } else {
                scrollContainer.scrollTop = currentScroll;
            }
        }, 16);
    }, HIGHSCORE_TOP_WAIT);
}

function onHighScoreScrollComplete() {
    if (scannedTeamData) return;
    
    // Fade out the high score display first
    const highScoreDisplay = document.getElementById('highScoreDisplay');
    highScoreDisplay.classList.remove('visible');
    
    // Wait for fade out, then switch to team
    setTimeout(() => {
        // Move to next team
        currentTeamIndex = (currentTeamIndex + 1) % teamScores.length;
        displayCurrentTeam();
        
        // Schedule next cycle
        scheduleNextCycle();
    }, 500);
}

// Helper function to escape HTML
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function displayTeam(teamData, isScanned) {
    const teamDisplay = document.getElementById('teamDisplay');
    
    // Fade out
    teamDisplay.classList.remove('visible');
    
    setTimeout(() => {
        // Create scorecard table
        const playersGrid = document.getElementById('playersGrid');
        playersGrid.innerHTML = '';
        
        if (teamData.players && teamData.players.length > 0) {
            const scorecardTable = createScorecardTable(teamData.players);
            playersGrid.appendChild(scorecardTable);
        }
        
        // Fade in
        teamDisplay.classList.add('visible');
    }, 300);
}

function startCycling() {
    if (cycleInterval) clearTimeout(cycleInterval);
    
    // Start with team display
    currentDisplayMode = 'team';
    
    // Use a custom cycling approach with setTimeout for different durations
    scheduleNextCycle();
}

function scheduleNextCycle() {
    if (scannedTeamData) return; // Stop if showing scanned team
    
    // Only schedule for team display - high scores handles its own timing via scroll
    if (currentDisplayMode === 'team') {
        cycleInterval = setTimeout(() => {
            if (scannedTeamData) return;
            
            // After team, show high scores (which handles its own cycle completion)
            displayHighScores();
        }, CYCLE_DURATION);
    }
    // High scores mode: timing is handled by startHighScoreAutoScroll -> onHighScoreScrollComplete
}

function stopCycling() {
    if (cycleInterval) {
        clearTimeout(cycleInterval);
        cycleInterval = null;
    }
    clearHighScoreScrollTimers();
}

function createScorecardTable(players) {
    const table = document.createElement('table');
    table.className = 'scorecard-table';
    table.setAttribute('role', 'table');

    const caption = document.createElement('caption');
    caption.className = 'visually-hidden';
    caption.textContent = 'Per-player hole scores and totals';
    table.appendChild(caption);
    
    const holeOrder = ['Plinko', 'SpinningTop', 'Haphazard', 'Roundhouse', 'HillHop', 'SkiJump', 'Mastermind', 'Igloo', 'Octagon', 'LoopDeLoop', 'UpAndOver', 'Lopside'];
    
    // Create header
    const thead = document.createElement('thead');
    const headerRow = document.createElement('tr');
    
    const playerHeader = document.createElement('th');
    playerHeader.className = 'player-name-header';
    playerHeader.textContent = 'Player';
    headerRow.appendChild(playerHeader);
    
    holeOrder.forEach((holeId) => {
        const holeName = HOLE_NAMES[holeId] || holeId;
        const th = document.createElement('th');
        th.className = 'hole-header';
        const span = document.createElement('span');
        span.textContent = holeName;
        th.appendChild(span);
        headerRow.appendChild(th);
    });
    
    const totalHeader = document.createElement('th');
    totalHeader.className = 'total-header';
    totalHeader.textContent = 'Total';
    headerRow.appendChild(totalHeader);
    
    thead.appendChild(headerRow);
    table.appendChild(thead);
    
    // Create body rows
    const tbody = document.createElement('tbody');
    players.forEach(player => {
        const playerTotal = Object.values(player.scores || {}).reduce((sum, holeScore) => {
            return sum + (holeScore.total || 0);
        }, 0);
        
        const row = document.createElement('tr');
        
        const nameCell = document.createElement('th');
        nameCell.className = 'player-name-cell';
        nameCell.setAttribute('scope', 'row');
        nameCell.textContent = player.name;
        row.appendChild(nameCell);
        
        holeOrder.forEach(holeId => {
            const score = player.scores ? player.scores[holeId] : null;
            const scoreValue = score ? score.total : '-';
            const scoreClass = score ? (score.total > 0 ? 'positive-score' : score.total < 0 ? 'negative-score' : 'zero-score') : 'no-score';

            const scoreCell = document.createElement('td');
            scoreCell.className = `score-cell ${scoreClass}`;
            scoreCell.textContent = scoreValue;
            scoreCell.dataset.holeId = holeId;
            row.appendChild(scoreCell);
        });
        
        const totalClass = playerTotal > 0 ? 'positive-score' : playerTotal < 0 ? 'negative-score' : 'zero-score';
        const totalCell = document.createElement('td');
        totalCell.className = `total-cell ${totalClass}`;
        totalCell.textContent = playerTotal;
        row.appendChild(totalCell);
        
        tbody.appendChild(row);
    });
    
    table.appendChild(tbody);

    // Highlight best/worst per column
    try {
        const bodyRows = Array.from(tbody.querySelectorAll('tr'));
        const holeCount = holeOrder.length;
        for (let colIndex = 0; colIndex < holeCount; colIndex++) {
            let values = [];
            bodyRows.forEach(r => {
                const cell = r.querySelectorAll('td,th')[colIndex+1];
                if (!cell || cell.classList.contains('total-cell')) return;
                const raw = cell.textContent.trim();
                const num = parseInt(raw, 10);
                if (!isNaN(num)) {
                    values.push({ num, cell });
                }
            });
            if (values.length) {
                const max = Math.max(...values.map(v => v.num));
                const min = Math.min(...values.map(v => v.num));
                values.forEach(v => {
                    if (v.num === max && max > 0) v.cell.classList.add('best-score');
                    if (v.num === min && min < 0) v.cell.classList.add('worst-score');
                });
            }
        }
    } catch (e) {
        console.warn('Highlighting failed', e);
    }
    
    return table;
}

function showState(stateName) {
    document.querySelectorAll('.leaderboard-state').forEach(state => {
        state.classList.remove('active');
    });
    
    const stateElement = document.getElementById(stateName + 'State');
    if (stateElement) {
        stateElement.classList.add('active');
    }
    
    // Ensure hidden input stays focused for RFID capture
    setTimeout(() => {
        document.getElementById('hiddenRfidInput').focus();
    }, 100);
}

// Resume cycling after RFID scan display ends
function resumeCycling() {
    scannedTeamData = null;
    document.getElementById('countdownBar').style.width = '0%';
    document.getElementById('cycleIndicator').style.display = 'flex';
    
    // Resume cycling from where we left off
    if (teamScores.length > 0) {
        currentDisplayMode = 'team';
        displayCurrentTeam();
        startCycling();
    }
}
</script>

</body>
</html>
