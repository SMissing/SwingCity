<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#1a1a1a">
    <title>Hole <%= holeNumber %> - <%= hole.name %> - SwingCity</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700;900&display=swap" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/css/style.css?v=<%= Date.now() %>">
    <link rel="stylesheet" href="/css/unity-feel.css?v=<%= Date.now() %>">
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
</head>
<body>

<%
// Determine background pattern based on hole number
// Odd holes get stripes, even holes get zebra
const backgroundPattern = (holeNumber % 2 === 1) ? 'hole-stripes' : 'hole-zebra';
%>

<div class="tablet-container <%= backgroundPattern %> hole-<%= holeNumber %>">
    <!-- Top Scoreboard Button -->
    <button class="top-scoreboard-button" id="openScoreboardBtn" onclick="openTeamScoreboard()" style="display: none;">
        <svg width="32" height="32" viewBox="0 0 24 24" fill="white" xmlns="http://www.w3.org/2000/svg">
            <path d="M3 3v18h18V3H3zm16 16H5V5h14v14z"/>
            <path d="M7 7h10v2H7zM7 11h10v2H7zM7 15h7v2H7z"/>
        </svg>
    </button>
    
    <!-- Fullscreen Button for Mobile -->
    <button class="fullscreen-button" id="fullscreenBtn" onclick="toggleFullscreen()" style="display: none;">
        <svg width="32" height="32" viewBox="0 0 24 24" fill="white" xmlns="http://www.w3.org/2000/svg">
            <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/>
        </svg>
    </button>
    
    <!-- SwingCity Logo - Centered at top -->
    <div class="top-logo">
        <img src="/images/swingcity-main-logo.png" alt="SwingCity Interactive Arcade Golf" />
    </div>
    
    <div class="hole-header">
        <div class="hole-info">
            <div class="hole-logo">
                <%
                // Map hole names to image filenames
                const holeImageMap = {
                    'Plinko': 'Plinko',
                    'SpinningTop': 'SpinningTop_2lines',
                    'Haphazard': 'Haphazard',
                    'Roundhouse': 'Roundhouse', 
                    'HillHop': 'HillHop',
                    'SkiJump': 'SkiJump',
                    'Mastermind': 'Mastermind',
                    'Igloo': 'Igloo',
                    'Octagon': 'Octagon',
                    'LoopDeLoop': 'LoopDeLoop',
                    'UpAndOver': 'UpOver',
                    'Lopside': 'Lopside'
                };
                const imageFileName = holeImageMap[hole.name] || hole.name;
                %>
                                <% if (hole.name === 'Plinko') { %>
                                    <img src="/images/hole-names-png/1_Plinko_WhiteText_magenta_static.svg" 
                                             alt="Plinko" 
                                             class="hole-logo-image-fullsize"
                                             onerror="document.getElementById('fallback-text').style.display='block'; this.style.display='none';">
                                <% } else { %>
                                    <img src="/images/hole-names-png/<%= holeNumber %>_<%= imageFileName %>_WhiteText.png" 
                                             alt="<%= hole.name %>" 
                                             class="hole-logo-image-fullsize"
                                             onerror="document.getElementById('fallback-text').style.display='block'; this.style.display='none';">
                                <% } %>
                <!-- Fallback text if image doesn't load -->
                <div id="fallback-text" style="display: none;">
                    <h1>Hole <%= holeNumber %></h1>
                    <h2><%= hole.name %></h2>
                    <div class="par-info">Par <%= hole.par %></div>
                </div>
            </div>
        </div>
        <div class="hole-status" id="holeStatus">
            <span class="status-indicator waiting">Waiting for Team</span>
        </div>
    </div>

    <!-- Vertical Ball Indicator - Center Left -->
    <div class="vertical-status-indicator">
        <div class="status-circle" id="ball1Indicator" title="Ball 1"></div>
        <div class="status-circle" id="ball2Indicator" title="Ball 2"></div>
        <div class="status-circle" id="ball3Indicator" title="Ball 3"></div>
    </div>

    <!-- Ball Score Display - Next to Ball Indicators -->
    <div class="ball-score-display">
        <div class="ball-score-item" id="ballScore1"></div>
        <div class="ball-score-item" id="ballScore2"></div>
        <div class="ball-score-item" id="ballScore3"></div>
    </div>

    <!-- Bottom Text Border - HIDDEN -->
    <div class="bottom-text-border" id="bottomTextBorder" style="display: none !important;">
        <!-- Text content can be dynamically updated -->
    </div>

    <!-- Waiting State -->
    <div class="game-state waiting-state active" id="waitingState">
        <div class="rfid-prompt" id="rfidPrompt">
            <div class="rfid-icon" id="rfidIcon">
                <svg width="100" height="100" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <!-- Center dot -->
                    <circle cx="50" cy="50" r="6" fill="#FFFFFF"/>
                    
                    <!-- Inner wave -->
                    <path d="M35 35 Q50 20, 65 35" stroke="#FFFFFF" stroke-width="4" stroke-linecap="round" fill="none"/>
                    <path d="M35 65 Q50 80, 65 65" stroke="#FFFFFF" stroke-width="4" stroke-linecap="round" fill="none"/>
                    
                    <!-- Middle wave -->
                    <path d="M25 25 Q50 5, 75 25" stroke="#FFFFFF" stroke-width="4" stroke-linecap="round" fill="none"/>
                    <path d="M25 75 Q50 95, 75 75" stroke="#FFFFFF" stroke-width="4" stroke-linecap="round" fill="none"/>
                    
                    <!-- Outer wave -->
                    <path d="M15 15 Q50 -10, 85 15" stroke="#FFFFFF" stroke-width="4" stroke-linecap="round" fill="none"/>
                    <path d="M15 85 Q50 110, 85 85" stroke="#FFFFFF" stroke-width="4" stroke-linecap="round" fill="none"/>
                </svg>
            </div>
            <div class="loading-spinner" id="loadingSpinner" style="display: none;">
                <div class="spinner"></div>
            </div>
            <h3 id="rfidPromptTitle">Tap your team card to start</h3>
            <p id="rfidPromptMessage">Hold your RFID card near the reader</p>
            <div id="rfidPromptTest" style="margin-top: 30px; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.2);">
                <p style="font-size: 0.9rem; opacity: 0.7;">üß™ Test Mode: Press "1" + Enter to load test team</p>
                <p style="font-size: 0.8rem; opacity: 0.5; margin-top: 10px;">üî• Firebase Test: Press "F" + Enter to load real Firebase team</p>
                <p style="font-size: 0.7rem; opacity: 0.4; margin-top: 5px;">üîß Debug: Press "D" to manually update ball scores</p>
            </div>
        </div>
    </div>

    <!-- Playing State -->
    <div class="game-state playing-state" id="playingState">
        <!-- Current Player Display -->
        <div class="current-player-display">
            <div class="player-name" id="currentPlayerName">Player Name</div>
            <div class="player-hole-score-fixed" id="currentPlayerScore">0</div>
        </div>
        
        <!-- Bottom Team Members Border -->
        <div class="bottom-team-border" id="bottomTeamBorder">
            <!-- Team members will be dynamically populated here -->
        </div>
    </div>

    <!-- Completed State -->
    <div class="game-state completed-state" id="completedState">
        <div class="completion-message">
            <div class="completion-icon">‚úÖ</div>
            <h3>Hole Complete!</h3>
            <div class="hole-summary" id="holeSummary">
                <p>Score: <span id="finalScore">0</span></p>
                <p id="scoreDescription"></p>
            </div>
            <div class="next-actions">
                <button class="next-hole-btn" onclick="proceedToNextHole()">
                    Continue to Next Hole
                </button>
                <button class="finish-game-btn" onclick="finishGame()" style="display: none;">
                    Finish Game
                </button>
            </div>
        </div>
    </div>

    <!-- Error State -->
    <div class="game-state error-state" id="errorState">
        <div class="error-message">
            <div class="error-icon">‚ö†Ô∏è</div>
            <h3>Something went wrong</h3>
            <p id="errorText">Please try again or contact staff for assistance.</p>
            <button class="retry-btn" onclick="resetToWaiting()">
                Try Again
            </button>
        </div>
    </div>
</div>

<!-- Team Scoreboard Modal -->
<div class="team-scoreboard-modal" id="teamScoreboardModal">
    <div class="scoreboard-content" style="background: var(--bg-card); border-radius: 18px; box-shadow: 0 8px 32px #000a; padding: 0; min-width: 340px; max-width: 98vw;">
        <div class="scoreboard-header" style="display: flex; align-items: center; justify-content: space-between; padding: 24px 32px 12px 32px; border-bottom: 1px solid var(--border-color); background: var(--bg-dark); border-radius: 18px 18px 0 0;">
            <div style="display: flex; align-items: center; gap: 18px;">
                <img src="/images/swingcity-logo.png" alt="SwingCity" class="leaderboard-logo" style="height: 48px; width: auto;">
                <h2 style="margin: 0; font-size: 2rem; font-weight: 800; color: var(--primary-color); letter-spacing: 1px;">Team Scoreboard</h2>
            </div>
            <button class="close-modal-btn" onclick="closeTeamScoreboard()" style="font-size: 2rem; background: none; border: none; color: var(--text-light); cursor: pointer;">‚úï</button>
        </div>
        <div class="scoreboard-body" style="padding: 24px 32px 32px 32px;">
            <div class="modal-team-info" id="modalTeamInfo" style="margin-bottom: 18px;">
                <h3 id="modalTeamName" style="font-size: 1.5rem; font-weight: 700; color: var(--accent-color); margin-bottom: 8px;">Team Name</h3>
                <div class="modal-team-stats" style="display: flex; gap: 32px; flex-wrap: wrap;">
                    <div class="modal-stat">
                        <span class="label">Holes Completed</span>
                        <span class="value" id="modalHolesCompleted">0</span>
                    </div>
                </div>
            </div>
            <div class="modal-scorecard-container players-grid" id="modalScorecardContainer" style="overflow-x: auto;">
                <!-- Scorecard table will be dynamically generated -->
            </div>
        </div>
    </div>
</div>

<!-- Debug Info (remove in production) -->
<div class="debug-info">
    <h4>Debug Info:</h4>
    <p>Hole: <%= holeNumber %> (<%= hole.name %>)</p>
    <p>Par: <%= hole.par %></p>
    <p>Config: <%= JSON.stringify(hole) %></p>
    <p>Socket Status: <span id="socketStatus">Connecting...</span></p>
</div>

<script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
<script src="/js/image-autocrop.js"></script>
<script src="/js/main.js"></script>
<script>
// Global variables
let currentTeam = null;
let selectedScore = null;
let socket = null;
const holeNumber = <%= holeNumber %>;
const holeConfig = <%- JSON.stringify(hole) %>;

// Score overlay shake configuration
const SCORE_SHAKE = {
    frequency: 12,   // Hz - how fast it shakes
    depth: 24,       // px - initial amplitude (will decay)
    duration: 1500   // ms - time to decay to 0
};
// Negative panel droop configuration
const SCORE_DROOP = {
    drop: 32,       // px - how far the text droops down
    duration: 600   // ms - time to reach full droop
};

// Make hole data available globally for RFID handler
window.holeData = {
    number: holeNumber,
    name: '<%= hole.name %>',
    config: holeConfig
};

// Allow page to configure positive sounds via window.POSITIVE_PANEL_SOUNDS; fallback to defaults if empty
window.POSITIVE_PANEL_SOUNDS = (Array.isArray(window.POSITIVE_PANEL_SOUNDS) && window.POSITIVE_PANEL_SOUNDS.length)
        ? window.POSITIVE_PANEL_SOUNDS
        : [
                '/sounds/posPointsSweep.wav',
                '/sounds/posPointsCam.wav',
                '/sounds/posPointsStab.wav'
            ];
// Allow page to configure negative sounds; fallback to defaults if empty
window.NEGATIVE_PANEL_SOUNDS = (Array.isArray(window.NEGATIVE_PANEL_SOUNDS) && window.NEGATIVE_PANEL_SOUNDS.length)
    ? window.NEGATIVE_PANEL_SOUNDS
    : [
        '/sounds/negPointsBass.wav',
        '/sounds/negPointsSweep.wav'
        ];
let __positiveSoundsCache = [];
let __negativeSoundsCache = [];
let __lastPositivePlayAt = 0;
let __lastNegativePlayAt = 0;
    let __audioUnlocked = false;
    let __audioCtx = null;

// Initialize when page loads
document.addEventListener('DOMContentLoaded', function() {
    initializeSocket();
    resetToWaiting();
    initializeFullscreen();
    initializeDynamicSizing();
    // Preload positive/negative panel sounds if provided by page
    if (Array.isArray(window.POSITIVE_PANEL_SOUNDS) && window.POSITIVE_PANEL_SOUNDS.length) {
        preloadSounds(window.POSITIVE_PANEL_SOUNDS);
    }
    if (Array.isArray(window.NEGATIVE_PANEL_SOUNDS) && window.NEGATIVE_PANEL_SOUNDS.length) {
        preloadNegativeSounds(window.NEGATIVE_PANEL_SOUNDS);
    }
    // Install one-time unlock handler to satisfy mobile autoplay policies
    const unlock = () => enableAudio(true);
        document.addEventListener('pointerdown', unlock, { once: true, capture: true });
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') enableAudio(true);
        }, { once: true, capture: true });
        // If sounds configured, show a gentle prompt until unlocked
    if (window.POSITIVE_PANEL_SOUNDS.length || window.NEGATIVE_PANEL_SOUNDS.length) ensureSoundPrompt();
});

// (Removed OSC debug listener and overlay)

// Dynamic sizing system for current player display
function initializeDynamicSizing() {
    calculateAndSetDynamicSizes();
    
    // Recalculate on window resize and orientation change
    window.addEventListener('resize', debounce(calculateAndSetDynamicSizes, 100));
    window.addEventListener('orientationchange', () => {
        setTimeout(calculateAndSetDynamicSizes, 200);
    });
}

function calculateAndSetDynamicSizes() {
    // Get the actual positions of the top and bottom elements
    const topLogo = document.querySelector('.top-logo');
    const holeHeader = document.querySelector('.hole-header');
    const bottomBorder = document.querySelector('.bottom-team-border');
    
    let topOffset = 280; // Default fallback
    let bottomOffset = 128; // Default bottom border height
    
    // Calculate actual top offset (logo + header height)
    if (topLogo && holeHeader) {
        const logoRect = topLogo.getBoundingClientRect();
        const headerRect = holeHeader.getBoundingClientRect();
        topOffset = Math.max(logoRect.bottom, headerRect.bottom);
    } else if (holeHeader) {
        const headerRect = holeHeader.getBoundingClientRect();
        topOffset = headerRect.bottom;
    }
    
    // Calculate actual bottom offset
    if (bottomBorder) {
        const borderRect = bottomBorder.getBoundingClientRect();
        bottomOffset = borderRect.height || 128;
    }
    
    // Calculate available height for current player display
    const viewportHeight = window.innerHeight;
    const availableHeight = viewportHeight - topOffset - bottomOffset;
    
    // Calculate font sizes based on available space
    // Each section (name and score) gets roughly half the available height
    const sectionHeight = availableHeight / 2;
    
    // Base the font size on a percentage of the section height
    // Use a reasonable scaling factor to prevent text from being too large or small
    const nameSize = Math.max(2, Math.min(sectionHeight * 0.25, 8)); // Between 2rem and 8rem
    const scoreSize = Math.max(2, Math.min(nameSize * 0.65, 6)); // Score is 65% of name size (was 50%), capped at 6rem
    
    // Set CSS custom properties
    document.documentElement.style.setProperty('--top-offset', `${topOffset}px`);
    document.documentElement.style.setProperty('--available-height', `${availableHeight}px`);
    document.documentElement.style.setProperty('--player-name-size', `${nameSize}rem`);
    document.documentElement.style.setProperty('--player-score-size', `${scoreSize}rem`);
    
    console.log(`üéØ Dynamic sizing calculated:`, {
        topOffset: topOffset + 'px',
        availableHeight: availableHeight + 'px',
        nameSize: nameSize + 'rem',
        scoreSize: scoreSize + 'rem'
    });
}

// Debounce utility to prevent excessive recalculations
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// Fullscreen functionality for Android tablets
function initializeFullscreen() {
    // Check if we're on a mobile device
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const isAndroid = /Android/i.test(navigator.userAgent);
    
    // Set CSS custom property for viewport height (fixes mobile browser issues)
    function setViewportHeight() {
        const vh = window.innerHeight * 0.01;
        document.documentElement.style.setProperty('--vh', `${vh}px`);
    }
    
    setViewportHeight();
    window.addEventListener('resize', setViewportHeight);
    window.addEventListener('orientationchange', () => {
        setTimeout(setViewportHeight, 100);
    });
    
    // Function to request fullscreen
    const requestFullscreen = () => {
        const docEl = document.documentElement;
        if (docEl.requestFullscreen) {
            docEl.requestFullscreen().catch(err => {
                console.log('Fullscreen request failed:', err);
                hideBrowserUI();
            });
        } else if (docEl.webkitRequestFullscreen) {
            docEl.webkitRequestFullscreen();
        } else if (docEl.msRequestFullscreen) {
            docEl.msRequestFullscreen();
        } else if (docEl.mozRequestFullScreen) {
            docEl.mozRequestFullScreen();
        } else {
            hideBrowserUI();
        }
    };
    
    // Function to exit fullscreen
    const exitFullscreen = () => {
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        } else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
        }
        document.body.classList.remove('fullscreen-active');
    };
    
    // Fallback method to hide browser UI
    const hideBrowserUI = () => {
        // Force landscape orientation if possible
        if (screen.orientation && screen.orientation.lock) {
            screen.orientation.lock('landscape').catch(() => {
                console.log('Could not lock orientation');
            });
        }
        
        // Hide address bar on mobile browsers
        window.scrollTo(0, 1);
        setTimeout(() => {
            window.scrollTo(0, 0);
            document.body.classList.add('fullscreen-active');
        }, 100);
        
        // Add meta tag to hide status bar if not already present
        let metaTag = document.querySelector('meta[name="theme-color"]');
        if (metaTag) {
            metaTag.content = '#000000';
        }
    };
    
    // Automatically request fullscreen after page load
    setTimeout(() => {
        requestFullscreen();
    }, 1000);
    
    // Setup 4-tap sequence on team status bar to exit fullscreen
    const teamStatusBar = document.querySelector('.status-indicator');
    if (teamStatusBar) {
        let tapCount = 0;
        let tapTimer;
        const maxTapInterval = 800; // Max time between taps (ms)
        
        teamStatusBar.addEventListener('click', (e) => {
            tapCount++;
            
            // Clear existing timer
            if (tapTimer) {
                clearTimeout(tapTimer);
            }
            
            // Check if we reached 4 taps
            if (tapCount >= 4) {
                // Vibrate if available
                if (navigator.vibrate) {
                    navigator.vibrate([100, 50, 100, 50, 100]);
                }
                
                // Toggle fullscreen based on current state
                const isCurrentlyFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || 
                                                document.mozFullScreenElement || document.msFullscreenElement);
                
                if (isCurrentlyFullscreen) {
                    // Exit fullscreen
                    exitFullscreen();
                    showToggleMessage(false);
                } else {
                    // Enter fullscreen
                    requestFullscreen();
                    showToggleMessage(true);
                }
                
                // Reset tap count
                tapCount = 0;
                return;
            }
            
            // Set timer to reset tap count if no more taps come
            tapTimer = setTimeout(() => {
                tapCount = 0;
            }, maxTapInterval);
            
            // Visual feedback for taps
            teamStatusBar.style.transform = 'scale(0.95)';
            
            // Show tap count indicator
            showTapCountIndicator(tapCount);
            
            setTimeout(() => {
                teamStatusBar.style.transform = '';
            }, 100);
        });
        
        // Prevent context menu on the status bar
        teamStatusBar.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            return false;
        });
    }
    
    // Show message when toggling fullscreen
    function showToggleMessage(enteringFullscreen) {
        const message = document.createElement('div');
        message.id = 'fullscreen-toggle-message';
        
        if (enteringFullscreen) {
            message.textContent = 'Entered fullscreen mode. Tap team status 4 times quickly to exit fullscreen.';
        } else {
            message.textContent = 'Exited fullscreen mode. Tap team status 4 times quickly to enter fullscreen again.';
        }
        
        message.style.cssText = `
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 10000;
            font-size: 14px;
            text-align: center;
            max-width: 90%;
        `;
        document.body.appendChild(message);
        
        setTimeout(() => {
            if (message.parentNode) {
                message.parentNode.removeChild(message);
            }
        }, 3000);
    }
    
    // Prevent context menu on long press (except on team status bar)
    document.addEventListener('contextmenu', (e) => {
        if (!e.target.classList.contains('status-indicator')) {
            e.preventDefault();
            return false;
        }
    });
    
    // Prevent text selection
    document.addEventListener('selectstart', (e) => {
        e.preventDefault();
        return false;
    });
    
    // Prevent default touch behaviors that could exit fullscreen
    document.addEventListener('touchstart', (e) => {
        if (e.touches.length > 1) {
            e.preventDefault();
        }
    }, { passive: false });
    
    document.addEventListener('touchmove', (e) => {
        if (e.touches.length > 1) {
            e.preventDefault();
        }
    }, { passive: false });
    
    // Prevent accidental navigation gestures
    document.addEventListener('gesturestart', (e) => {
        e.preventDefault();
    });
    
    document.addEventListener('gesturechange', (e) => {
        e.preventDefault();
    });
    
    document.addEventListener('gestureend', (e) => {
        e.preventDefault();
    });
    
    // Re-enable fullscreen when page becomes visible again (only if user hasn't manually exited)
    let userManuallyExitedFullscreen = false;
    
    document.addEventListener('visibilitychange', () => {
        if (!document.hidden && !document.fullscreenElement && !userManuallyExitedFullscreen) {
            // Page became visible and not in fullscreen, and user didn't manually exit
            setTimeout(() => {
                requestFullscreen();
            }, 1000); // Longer delay to be less aggressive
        }
    });
    
    // Re-enable fullscreen on window focus (only if user hasn't manually exited)
    window.addEventListener('focus', () => {
        if (!document.fullscreenElement && !userManuallyExitedFullscreen) {
            setTimeout(() => {
                requestFullscreen();
            }, 1000); // Longer delay to be less aggressive
        }
    });
    
    // Listen for fullscreen changes and track user manual exits
    const fullscreenEvents = ['fullscreenchange', 'webkitfullscreenchange', 'mozfullscreenchange', 'MSFullscreenChange'];
    fullscreenEvents.forEach(event => {
        document.addEventListener(event, () => {
            const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || 
                                  document.mozFullScreenElement || document.msFullscreenElement);
            
            if (isFullscreen) {
                console.log('Entered fullscreen mode');
                document.body.classList.add('fullscreen-active');
                // Additional mobile optimizations
                if (isAndroid) {
                    setTimeout(() => {
                        window.scrollTo(0, 1);
                        setTimeout(() => window.scrollTo(0, 0), 50);
                    }, 100);
                }
            } else {
                console.log('Exited fullscreen mode');
                document.body.classList.remove('fullscreen-active');
                // User exited fullscreen - assume it was manual for now
                userManuallyExitedFullscreen = true;
                // Reset this flag after some time so auto-fullscreen can work again later
                setTimeout(() => {
                    userManuallyExitedFullscreen = false;
                }, 30000); // Reset after 30 seconds
            }
        });
    });
}

// Function to toggle fullscreen manually
function toggleFullscreen() {
    if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(err => {
            console.log('Error attempting to enable fullscreen:', err.message);
        });
    } else {
        document.exitFullscreen();
    }
}

function initializeSocket() {
    socket = io();
    
    socket.on('connect', function() {
        console.log('Connected to server');
        document.getElementById('socketStatus').textContent = 'Connected';
        
        // Register this tablet with the server
        socket.emit('tablet-register', {
            holeId: window.holeData.name,
            tabletId: `tablet-${holeNumber}`
        });
    // (OSC debug listener removed)
    });
    
    socket.on('disconnect', function() {
        console.log('Disconnected from server');
        document.getElementById('socketStatus').textContent = 'Disconnected';
    });
    
    // Handle game started from RFID tap
    socket.on('game-started', function(gameData) {
        console.log('üéÆ Game started event received:', gameData);
        if (gameData.holeId === window.holeData.name || gameData.holeId === holeNumber) {
            handleGameStarted(gameData);
        }
    });
    
    // Handle hole state updates (when reconnecting or initial load)
    socket.on('hole-state-update', function(holeState) {
        console.log('üèåÔ∏è Hole state update received:', holeState);
        if (holeState && holeState.status === 'playing') {
            handleGameStarted(holeState);
            try {
                // After restoring game, set throws/indicators to current state
                const holeId = String(holeState.holeId || (window.holeData && window.holeData.name) || '').toString();
                const pIndex = holeState.currentPlayerIndex || 0;
                const player = (holeState.players && holeState.players[pIndex]) ? holeState.players[pIndex] : null;
                const holeScores = player && player.scores ? player.scores[holeId] : null;
                const throws = (holeScores && Array.isArray(holeScores.throws)) ? holeScores.throws : [];
                updateBallScoresFromThrows(throws);
                const throwCount = typeof holeState.currentThrow === 'number' ? holeState.currentThrow : throws.length;
                setCumulativeBallIndicators(throwCount);
                // Update center score number to hole total
                const total = (holeScores && typeof holeScores.total === 'number') ? holeScores.total : 0;
                const scoreEl = document.getElementById('currentPlayerScore');
                if (scoreEl) scoreEl.textContent = total;
            } catch(err) {
                console.warn('Failed to restore throw indicators from hole state:', err);
            }
        }
    });
    
    // Handle game reset from admin
    socket.on('game-reset', function(data) {
        console.log('üîÑ Game reset received:', data);
        if (data.holeId === window.holeData.name) {
            resetToWaiting();
        }
    });
    
    // Handle legacy team-started event 
    socket.on('team-started', function(data) {
        if (data.hole === holeNumber) {
            handleTeamStarted(data);
        }
    });
    
    socket.on('score-recorded', function(data) {
        if (data.hole === holeNumber) {
            handleScoreRecorded(data);
        }
    });
    
    socket.on('hole-completed', function(data) {
        if (data.hole === holeNumber) {
            handleHoleCompleted(data);
        }
    });

    // New: handle unified score updates from server
    socket.on('score-update', function(gameData) {
        try {
            if (!gameData || !gameData.holeId) return;
            const thisHole = (window.holeData && window.holeData.name) ? String(window.holeData.name).toLowerCase() : '';
            if (String(gameData.holeId).toLowerCase() !== thisHole) return; // ignore other holes

            const pIndex = gameData.currentPlayerIndex || 0;
            const player = (gameData.players && gameData.players[pIndex]) ? gameData.players[pIndex] : null;
            const holeScores = player && player.scores ? player.scores[gameData.holeId] : null;
            const throws = (holeScores && Array.isArray(holeScores.throws)) ? holeScores.throws : [];
            const total = (holeScores && typeof holeScores.total === 'number') ? holeScores.total : 0;
            const throwCount = throws.length;
            const lastScore = throwCount > 0 ? throws[throwCount - 1] : null;

            // Update center score immediately
            const scoreEl = document.getElementById('currentPlayerScore');
            if (scoreEl) scoreEl.textContent = total;

            // Update bottom team border (current player highlight and total) if available
            updateBottomPlayersDisplay();

            // Update per-throw labels next to ball indicators
            updateBallScoresFromThrows(throws);

            // Cumulative indicators: after 1 throw => BI1, after 2 => BI1+BI2, after 3 => all
            setCumulativeBallIndicators(throwCount);

            // Show 3s overlay panel for the last score, then finalize visuals
            if (lastScore !== null && lastScore !== undefined) {
                showScoreOverlayPanel(lastScore, function() {
                    // After overlay hides, ensure UI reflects the latest state
                    updateBallScoresFromThrows(throws);
                    setCumulativeBallIndicators(throwCount);
                });
            }
        } catch (err) {
            console.error('Error handling score-update:', err);
        }
    });
    
    socket.on('error', function(data) {
        showError(data.message || 'An unknown error occurred');
    });
}

function resetToWaiting() {
    currentTeam = null;
    selectedScore = null;
    
    // Hide current player display
    const currentPlayerDisplay = document.querySelector('.current-player-display');
    if (currentPlayerDisplay) {
        currentPlayerDisplay.classList.remove('show');
    }
    
    // Hide bottom border
    const bottomBorder = document.getElementById('bottomTeamBorder');
    if (bottomBorder) {
        bottomBorder.classList.remove('show');
        bottomBorder.innerHTML = ''; // Clear content
    }
    
    // Hide scoreboard button since no team is active
    updateScoreboardButtonVisibility();
    
    showState('waiting');
    updateStatus('Waiting for Team', 'waiting');
}

function showState(stateName) {
    // Hide all states
    document.querySelectorAll('.game-state').forEach(state => {
        state.classList.remove('active');
    });
    
    // Show requested state
    const stateElement = document.getElementById(stateName + 'State');
    if (stateElement) {
        stateElement.classList.add('active');
    }
}

function updateStatus(message, className) {
    const statusElement = document.getElementById('holeStatus');
    const indicator = statusElement.querySelector('.status-indicator');
    indicator.textContent = message;
    indicator.className = `status-indicator ${className}`;
}

function handleGameStarted(gameData) {
    console.log('üéÆ Processing game started data:', gameData);
    
    // Convert server game data to our expected format
    currentTeam = {
        rfid: gameData.rfid,
        name: gameData.teamName,
        teamName: gameData.teamName,
        totalScore: 0,
        holesCompleted: 0,
        players: gameData.players || []
    };
    
    // Handle different player data formats from Firebase
    if (gameData.players) {
        if (Array.isArray(gameData.players)) {
            // Already in array format
            currentTeam.players = gameData.players;
            console.log('üìä Using array format players:', currentTeam.players);
        } else if (typeof gameData.players === 'object') {
            // Convert Firebase object format to array
            currentTeam.players = Object.keys(gameData.players).map(playerId => {
                const playerData = gameData.players[playerId];
                console.log(`üë§ Converting player ${playerId}:`, playerData);
                console.log(`üìä Player's scorePerHole:`, playerData.scorePerHole);
                return {
                    id: playerId,
                    name: playerData.displayName || playerId.replace(/[@_]/g, ' '),
                    scores: playerData.scorePerHole || {}, // This is the key - scorePerHole from Firebase
                    totalScore: playerData.totalScoreForThisVisit || 0
                };
            });
            console.log('üîÑ Converted Firebase players to array format:', currentTeam.players);
        }
    }
    
    console.log('üîÑ Final converted team data:', currentTeam);
    console.log('üë• Players with scorePerHole data:', currentTeam.players);
    
    // Calculate total score from player data
    currentTeam.totalScore = currentTeam.players.reduce((total, player) => {
        return total + (player.totalScore || 0);
    }, 0);
    
    // Reset RFID prompt state
    resetRFIDPromptState();
    
    // Recalculate dynamic sizing before showing player display
    calculateAndSetDynamicSizes();
    
    // Show the current player in center with animation
    updateCurrentPlayerDisplay();
    const currentPlayerDisplay = document.querySelector('.current-player-display');
    if (currentPlayerDisplay) {
        currentPlayerDisplay.classList.add('show');
    }
    
    // Show other team players in bottom border with slide-up animation
    updateBottomPlayersDisplay();
    const bottomBorder = document.getElementById('bottomTeamBorder');
    if (bottomBorder) {
        bottomBorder.classList.add('show');
    }
    
    // Start with no indicators lit (Ball1 state)
    resetBallIndicators();
    
    // Update ball score display with Firebase data
    console.log('üéØ About to call updateBallScoreDisplay() with converted team data');
    updateBallScoreDisplay();
    
    // Show scoreboard button now that we have team data
    updateScoreboardButtonVisibility();
    
    showState('playing');
    updateStatus(`${currentTeam.name} Playing`, 'playing');
    
    console.log('‚úÖ Game started successfully for:', currentTeam.name);
}

function handleTeamStarted(data) {
    currentTeam = data.team;
    
    // Show the current player in center with animation
    updateCurrentPlayerDisplay();
    const currentPlayerDisplay = document.querySelector('.current-player-display');
    if (currentPlayerDisplay) {
        currentPlayerDisplay.classList.add('show');
    }
    
    // Show other team players in bottom border with slide-up animation
    updateBottomPlayersDisplay();
    const bottomBorder = document.getElementById('bottomTeamBorder');
    if (bottomBorder) {
        bottomBorder.classList.add('show');
    }
    
    // Start with no indicators lit (Ball1 state)
    resetBallIndicators();
    
    // Show scoreboard button now that we have team data
    updateScoreboardButtonVisibility();
    
    showState('playing');
    updateStatus(`${data.team.name} Playing`, 'playing');
}

function updateCurrentPlayerDisplay() {
    if (!currentTeam || !currentTeam.players || currentTeam.players.length === 0) return;
    
    // For now, show the first player (this could be dynamic based on game state)
    const currentPlayer = currentTeam.players[0];
    
    // Update player name
    const playerNameElement = document.getElementById('currentPlayerName');
    if (playerNameElement) {
        playerNameElement.textContent = currentPlayer.name || 'Player';
    }
    
    // Update player's score for this hole
    const playerScoreElement = document.getElementById('currentPlayerScore');
    if (playerScoreElement) {
        const holeNames = ['Plinko', 'SpinningTop', 'Haphazard', 'Roundhouse', 'HillHop', 'SkiJump', 'Mastermind', 'Igloo', 'Octagon', 'LoopDeLoop', 'UpAndOver', 'Lopside'];
        const currentHoleId = holeNames[holeNumber - 1];
        
        let holeScore = 0;
        if (currentPlayer.scores && currentPlayer.scores[currentHoleId]) {
            holeScore = currentPlayer.scores[currentHoleId].total || 0;
        }
        
        playerScoreElement.textContent = holeScore;
    }
}

function updateBottomPlayersDisplay() {
    const bottomBorder = document.getElementById('bottomTeamBorder');
    
    if (!bottomBorder) {
        console.log('‚ùå Bottom border element not found');
        return;
    }
    
    if (!currentTeam || !currentTeam.players || currentTeam.players.length === 0) {
        bottomBorder.innerHTML = '';
        return;
    }
    
    const holeNames = ['Plinko', 'SpinningTop', 'Haphazard', 'Roundhouse', 'HillHop', 'SkiJump', 'Mastermind', 'Igloo', 'Octagon', 'LoopDeLoop', 'UpAndOver', 'Lopside'];
    const currentHoleId = holeNames[holeNumber - 1];
    
    let html = '';
    
    currentTeam.players.forEach((player, index) => {
        const isCurrentClass = index === 0 ? ' current' : '';
        html += `
            <div class="team-member${isCurrentClass}">
                <div class="team-member-name">${player.name || `Player ${index + 1}`}</div>
            </div>
        `;
    });
    
    bottomBorder.innerHTML = html;
}

function selectScore(score) {
    selectedScore = score;
    
    // Update button states
    document.querySelectorAll('.score-btn').forEach(btn => {
        btn.classList.remove('selected');
    });
    
    document.querySelector(`[data-score="${score}"]`).classList.add('selected');
    document.getElementById('submitScoreBtn').disabled = false;
}

function submitScore() {
    if (!selectedScore || !currentTeam) {
        showError('Please select a score');
        return;
    }
    
    const scoreData = {
        teamId: currentTeam.id,
        hole: holeNumber,
        score: selectedScore
    };
    
    // Send to server via API
    fetch('/api/score/input', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(scoreData)
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            // Score will be handled by socket event
            updateStatus('Recording Score...', 'processing');
        } else {
            showError(data.message || 'Failed to record score');
        }
    })
    .catch(error => {
        console.error('Error submitting score:', error);
        showError('Network error. Please try again.');
    });
}

function skipHole() {
    if (!currentTeam) return;
    
    // Record maximum score for skipped hole
    selectedScore = 8;
    submitScore();
}

function handleScoreRecorded(data) {
    // Update display with recorded score
    document.getElementById('finalScore').textContent = data.score;
    
    // Generate score description
    let description = '';
    const par = holeConfig.par;
    const score = data.score;
    
    if (score === 1) {
        description = 'HOLE IN ONE! üéâ';
    } else if (score === par - 2) {
        description = 'Eagle! ü¶Ö';
    } else if (score === par - 1) {
        description = 'Birdie! üê¶';
    } else if (score === par) {
        description = 'Par - Nice job! üëç';
    } else if (score === par + 1) {
        description = 'Bogey';
    } else if (score === par + 2) {
        description = 'Double Bogey';
    } else {
        description = 'Keep trying!';
    }
    
    document.getElementById('scoreDescription').textContent = description;
}

function handleHoleCompleted(data) {
    showState('completed');
    updateStatus('Hole Complete', 'completed');
    
    // Show appropriate next action button
    if (data.isLastHole) {
        document.querySelector('.next-hole-btn').style.display = 'none';
        document.querySelector('.finish-game-btn').style.display = 'block';
    }
}

function proceedToNextHole() {
    if (!currentTeam) return;
    
    // Redirect to next hole or leaderboard
    const nextHole = holeNumber + 1;
    if (nextHole <= 12) {
        window.location.href = `/tablet/${nextHole}`;
    } else {
        window.location.href = '/leaderboard';
    }
}

function finishGame() {
    window.location.href = '/leaderboard';
}

function showError(message) {
    document.getElementById('errorText').textContent = message;
    showState('error');
    updateStatus('Error', 'error');
}

// Auto-refresh connection if disconnected for too long
setInterval(function() {
    if (socket && !socket.connected) {
        console.log('Attempting to reconnect...');
        socket.connect();
    }
}, 5000);

// Ball Indicator Test Functionality - Click to toggle
document.addEventListener('DOMContentLoaded', function() {
    // Add click handlers to test ball indicators
    document.getElementById('ball1Indicator').addEventListener('click', function() {
        this.classList.toggle('active');
    });
    
    document.getElementById('ball2Indicator').addEventListener('click', function() {
        this.classList.toggle('active');
    });
    
    document.getElementById('ball3Indicator').addEventListener('click', function() {
        this.classList.toggle('active');
    });
});

// Function to activate ball indicator (call from game logic)
function activateBallIndicator(ballNumber) {
    const indicator = document.getElementById(`ball${ballNumber}Indicator`);
    if (indicator) {
        indicator.classList.add('active');
    }
}

// Function to deactivate ball indicator
function deactivateBallIndicator(ballNumber) {
    const indicator = document.getElementById(`ball${ballNumber}Indicator`);
    if (indicator) {
        indicator.classList.remove('active');
    }
}

// Function to reset all ball indicators
function resetBallIndicators() {
    for (let i = 1; i <= 3; i++) {
        deactivateBallIndicator(i);
    }
}

// Function to update bottom border text
function updateBottomText(text) {
    const bottomBorder = document.getElementById('bottomTextBorder');
    if (bottomBorder) {
        bottomBorder.textContent = text;
    }
}

// Ensure an overlay panel exists for showing the last score prominently
function ensureScoreOverlayPanel() {
    if (document.getElementById('scoreOverlayPanel')) return;
    const panel = document.createElement('div');
    panel.id = 'scoreOverlayPanel';
    panel.style.cssText = `
        display: none;
        position: fixed;
        inset: 0;
        width: 100vw;
        height: 100vh;
        z-index: 10000;
        align-items: center;
        justify-content: center;
        flex-direction: column;
    overflow: hidden;
    `;

    // Overscan layer that we actually shake (larger than viewport)
    const layer = document.createElement('div');
    layer.id = 'scoreOverlayLayer';
    layer.style.cssText = `
        position: absolute;
        top: -10vh;
        left: -10vw;
        width: 120vw;
        height: 120vh;
        background-repeat: repeat;
        will-change: transform;
        z-index: 1;
    `;
    panel.appendChild(layer);

    const text = document.createElement('div');
    text.id = 'scoreOverlayText';
    text.style.cssText = `
    font-size: 16vw;
    font-weight: 900;
    padding: 0.5vw 2vw;
    border-radius: 1.2vw;
    text-shadow: 0 8px 32px rgba(0,0,0,0.35);
    letter-spacing: 0.5vw;
    position: relative;
    z-index: 2;
    `;
    panel.appendChild(text);
    document.body.appendChild(panel);
}

// Show the overlay panel for 3 seconds with yellow for + and pink/red for -
function showScoreOverlayPanel(score, onDone) {
    ensureScoreOverlayPanel();
    const panel = document.getElementById('scoreOverlayPanel');
    const layer = document.getElementById('scoreOverlayLayer');
    const text = document.getElementById('scoreOverlayText');
    if (!panel || !layer || !text) return;

    if (score >= 0) {
        // Yellow stripes: light and darker yellow alternating (larger bands)
        layer.style.background = 'repeating-linear-gradient(45deg, #ffe36e 0 12vw, #d8b84a 12vw 24vw)';
    text.style.color = '#FFFFFFFF';
    text.style.background = 'transparent';
    text.style.textShadow = '0 10px 24px rgba(0,0,0,0.45)';
        playPositivePanelSounds();
    } else {
        // Use same magenta family as ball 1 indicator (ff44ff -> cc00cc)
        layer.style.background = 'repeating-linear-gradient(45deg, #ff44ff 0 14vw, #cc00cc 14vw 28vw)';
        text.style.color = '#FFFFFF';
        text.style.background = 'transparent';
        text.style.textShadow = '0 10px 32px rgba(255,0,255,0.55), 0 4px 12px rgba(0,0,0,0.55)';
        playNegativePanelSounds();
    }
    text.textContent = (score > 0 ? '+' : '') + score;

    panel.style.display = 'flex';
    // Positive = screen shake; Negative = droop the text a bit
    if (score >= 0) {
        startElementShake(layer, SCORE_SHAKE);
    } else {
        startElementDroop(text, SCORE_DROOP);
    }
    setTimeout(() => {
        panel.style.display = 'none';
        // Cleanup any transforms
        try { layer.style.transform = ''; } catch(_){}
        try { text.style.transform = ''; } catch(_){}
        if (typeof onDone === 'function') onDone();
    }, 3000);
}

// Update the three throw labels beside the ball indicators from an array of throws
function updateBallScoresFromThrows(throws) {
    const container = document.querySelector('.ball-score-display');
    if (container) {
        container.style.display = (throws && throws.length) ? 'flex' : 'none';
    }
    for (let i = 1; i <= 3; i++) {
        const el = document.getElementById(`ballScore${i}`);
        if (!el) continue;
        const val = (throws && throws[i - 1] !== undefined && throws[i - 1] !== null) ? throws[i - 1] : null;
        el.textContent = val === null ? '' : (val > 0 ? `+${val}` : `${val}`);
        el.classList.remove('positive', 'negative', 'zero', 'visible');
        if (val !== null) {
            if (val > 0) el.classList.add('positive');
            else if (val < 0) el.classList.add('negative');
            else el.classList.add('zero');
            el.classList.add('visible');
        }
    }
}

// Audio helpers for positive overlay
function preloadSounds(urls = []) {
    __positiveSoundsCache = urls.map(src => {
        const a = new Audio();
        a.src = src;
        a.preload = 'auto';
        return a;
    });
}

function preloadNegativeSounds(urls = []) {
    __negativeSoundsCache = urls.map(src => {
        const a = new Audio();
        a.src = src;
        a.preload = 'auto';
        return a;
    });
}

function playPositivePanelSounds() {
    try {
        const now = Date.now();
        if (now - __lastPositivePlayAt < 300) return; // throttle rapid replays
        __lastPositivePlayAt = now;

        const urls = Array.isArray(window.POSITIVE_PANEL_SOUNDS) ? window.POSITIVE_PANEL_SOUNDS : [];
        if (!urls.length) return;

        // Require user gesture unlock once
        if (!__audioUnlocked) {
            console.warn('Audio locked by browser autoplay policy. Tap to enable sound.');
            ensureSoundPrompt();
            return;
        }

        // If we preloaded, clone to avoid reusing the same element instance
        if (__positiveSoundsCache.length === urls.length && __positiveSoundsCache.length > 0) {
            __positiveSoundsCache.forEach(cached => {
                const a = cached.cloneNode();
                a.volume = 1.0;
                a.play().catch(() => {});
            });
        } else {
            urls.forEach(src => {
                const a = new Audio(src);
                a.volume = 1.0;
                a.play().catch(() => {});
            });
        }
    } catch (e) {
        // Autoplay restrictions can cause play() to reject; safe to ignore
    }
}

function playNegativePanelSounds() {
    try {
        const now = Date.now();
        if (now - __lastNegativePlayAt < 300) return; // throttle
        __lastNegativePlayAt = now;

        const urls = Array.isArray(window.NEGATIVE_PANEL_SOUNDS) ? window.NEGATIVE_PANEL_SOUNDS : [];
        if (!urls.length) return;

        if (!__audioUnlocked) {
            console.warn('Audio locked by browser autoplay policy. Tap to enable sound.');
            ensureSoundPrompt();
            return;
        }

        if (__negativeSoundsCache.length === urls.length && __negativeSoundsCache.length > 0) {
            __negativeSoundsCache.forEach(cached => {
                const a = cached.cloneNode();
                a.volume = 1.0;
                a.play().catch(() => {});
            });
        } else {
            urls.forEach(src => {
                const a = new Audio(src);
                a.volume = 1.0;
                a.play().catch(() => {});
            });
        }
    } catch (e) {
        // ignore
    }
}

function enableAudio(fromUserGesture = false) {
    try {
        if (__audioUnlocked) return;
        // Web Audio unlock pattern for iOS/Safari
        if (!__audioCtx) {
            const AudioCtx = window.AudioContext || window.webkitAudioContext;
            if (AudioCtx) {
                __audioCtx = new AudioCtx();
            }
        }
        if (__audioCtx && __audioCtx.state === 'suspended') {
            __audioCtx.resume().catch(() => {});
        }
        // Create and play a tiny silent buffer to satisfy policy
        if (__audioCtx && __audioCtx.state === 'running') {
            const buffer = __audioCtx.createBuffer(1, 1, 22050);
            const source = __audioCtx.createBufferSource();
            source.buffer = buffer;
            source.connect(__audioCtx.destination);
            source.start(0);
        }
    // Warm up HTMLAudio by attempting muted playback once per URL (allowed on user gesture)
    const posUrls = Array.isArray(window.POSITIVE_PANEL_SOUNDS) ? window.POSITIVE_PANEL_SOUNDS : [];
    const negUrls = Array.isArray(window.NEGATIVE_PANEL_SOUNDS) ? window.NEGATIVE_PANEL_SOUNDS : [];
    [...posUrls.slice(0, 3), ...negUrls.slice(0, 3)].forEach(src => {
            try {
                const a = new Audio(src);
                a.muted = true;
                a.play().then(() => {
                    // Stop quickly; goal is to satisfy gesture requirement
                    setTimeout(() => { try { a.pause(); a.src = ''; } catch(_){} }, 60);
                }).catch(() => {});
            } catch(_) {}
        });
        __audioUnlocked = true;
        hideSoundPrompt();
        console.log('Audio unlocked');
    } catch (e) {
        // Ignore
    }
}

function ensureSoundPrompt() {
    if (document.getElementById('sound-unlock-prompt') || !window.POSITIVE_PANEL_SOUNDS.length) return;
    const prompt = document.createElement('div');
    prompt.id = 'sound-unlock-prompt';
    prompt.textContent = 'Tap to enable sound';
    prompt.style.cssText = `
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        padding: 10px 16px;
        background: rgba(0,0,0,0.7);
        color: #fff;
        border-radius: 20px;
        font-size: 14px;
        z-index: 10001;
        pointer-events: auto;
    `;
    prompt.addEventListener('click', () => enableAudio(true));
    document.body.appendChild(prompt);
}

function hideSoundPrompt() {
    const el = document.getElementById('sound-unlock-prompt');
    if (el && el.parentNode) el.parentNode.removeChild(el);
}

// Decaying shake effect applied to an element
function startElementShake(element, cfg = {}) {
    const frequency = cfg.frequency ?? 12;    // Hz
    const depth = cfg.depth ?? 24;            // px
    const duration = cfg.duration ?? 1500;    // ms
    const start = performance.now();

    // Cancel any previous shake by keeping a token
    const token = Math.random().toString(36).slice(2);
    element.dataset.shakeToken = token;

    function frame(now) {
        // Abort if another shake started
        if (element.dataset.shakeToken !== token) {
            element.style.transform = '';
            return;
        }

        const elapsed = now - start;
        const t = Math.min(elapsed / duration, 1);
        const amp = depth * (1 - t); // linear decay to 0 by end
        const angle = 2 * Math.PI * frequency * (elapsed / 1000);

        // Slightly different axes to feel more organic
        const dx = Math.sin(angle) * amp;
        const dy = Math.cos(angle * 1.3) * amp * 0.8;

        element.style.transform = `translate(${dx}px, ${dy}px)`;

        if (t < 1) {
            requestAnimationFrame(frame);
        } else {
            element.style.transform = '';
            // Clear token when done
            if (element.dataset.shakeToken === token) {
                delete element.dataset.shakeToken;
            }
        }
    }
    requestAnimationFrame(frame);
}

// Simple one-way droop: translate Y from 0 to cfg.drop over cfg.duration with ease-out, then hold
function startElementDroop(element, cfg = {}) {
    const drop = cfg.drop ?? 32;        // px
    const duration = cfg.duration ?? 600; // ms
    const start = performance.now();
    const token = Math.random().toString(36).slice(2);
    element.dataset.droopToken = token;

    function easeOutCubic(t) {
        return 1 - Math.pow(1 - t, 3);
    }

    function frame(now) {
        if (element.dataset.droopToken !== token) return;
        const elapsed = now - start;
        const t = Math.min(elapsed / duration, 1);
        const y = drop * easeOutCubic(t);
        element.style.transform = `translate(0px, ${y}px)`;
        if (t < 1) {
            requestAnimationFrame(frame);
        }
    }
    requestAnimationFrame(frame);
}

// Light indicators cumulatively (1..throwCount). When throwCount is 0: none lit.
function setCumulativeBallIndicators(throwCount) {
    for (let i = 1; i <= 3; i++) {
        const indicator = document.getElementById(`ball${i}Indicator`);
        if (!indicator) continue;
        if (i <= throwCount) {
            indicator.classList.add('active');
        } else {
            indicator.classList.remove('active');
        }
    }
}

// Function to hide/show bottom border
function toggleBottomBorder(show = true) {
    const bottomBorder = document.getElementById('bottomTextBorder');
    if (bottomBorder) {
        bottomBorder.style.display = show ? 'flex' : 'none';
    }
}

// Team Scoreboard Modal Functions
async function openTeamScoreboard() {
    if (!currentTeam) {
        console.warn('No current team data available');
        return;
    }
    
    const modal = document.getElementById('teamScoreboardModal');
    if (modal) {
        // Show modal first
        modal.classList.add('active');
        
        // Update modal content with current data first (fast display)
        updateScoreboardModal();
        
        // If we don't have detailed player scores, fetch them
        const needsFullData = !currentTeam.players || 
                             currentTeam.players.length === 0 || 
                             !currentTeam.players.some(p => p.scores && Object.keys(p.scores).length > 0);
        
        if (needsFullData) {
            // Fetch full team data in background
            await fetchFullTeamData();
            // Update modal content with full data
            updateScoreboardModal();
        }
    }
}

async function fetchFullTeamData() {
    if (!currentTeam || !currentTeam.rfid) return;
    
    try {
        // Show loading state
        const container = document.getElementById('modalScorecardContainer');
        if (container) {
            container.innerHTML = `
                <div style="text-align: center; padding: 40px; color: #ccc;">
                    <div class="loading-spinner"></div>
                    <p style="margin-top: 20px;">Loading team scorecard...</p>
                </div>`;
        }
        
        const response = await fetch(`/api/team/${currentTeam.rfid}`);
        if (!response.ok) {
            throw new Error(`Failed to fetch team data: ${response.status}`);
        }
        
        const teamData = await response.json();
        
        // Update current team data with full player info
        if (teamData && teamData.players) {
            // Convert the API format to our expected format
            const fullTeamData = {
                ...currentTeam,
                players: teamData.players.map(player => ({
                    id: player.id,
                    name: player.name || player.displayName || player.id.replace(/[@_]/g, ' '),
                    scores: player.scores || {}
                })),
                totalScore: teamData.totalScore || 0,
                holesCompleted: teamData.holesCompleted || 0
            };
            
            // Update global currentTeam
            currentTeam = fullTeamData;
        } else {
            throw new Error('Invalid team data format received');
        }
    } catch (error) {
        console.error('Error fetching team data:', error);
        const container = document.getElementById('modalScorecardContainer');
        if (container) {
            container.innerHTML = `
                <div style="text-align: center; padding: 40px; color: #dc3545;">
                    <div style="font-size: 3rem; margin-bottom: 20px;">‚ö†Ô∏è</div>
                    <h4 style="color: #dc3545; margin-bottom: 15px;">Error Loading Data</h4>
                    <p style="margin-bottom: 20px;">Unable to load team scorecard</p>
                    <button onclick="fetchFullTeamData()" class="retry-btn" style="padding: 8px 16px; background: #dc3545; color: white; border: none; border-radius: 8px; cursor: pointer;">
                        Try Again
                    </button>
                </div>`;
        }
    }
}

// Convert Firebase score format to our expected format
function convertScoreFormat(firebaseScores) {
    const holeOrder = ['Plinko', 'SpinningTop', 'Haphazard', 'Roundhouse', 'HillHop', 'SkiJump', 'Mastermind', 'Igloo', 'Octagon', 'LoopDeLoop', 'UpAndOver', 'Lopside'];
    const convertedScores = {};
    
    holeOrder.forEach(holeId => {
        if (firebaseScores[holeId] !== undefined) {
            convertedScores[holeId] = {
                total: firebaseScores[holeId]
            };
        }
    });
    
    return convertedScores;
}

function closeTeamScoreboard() {
    const modal = document.getElementById('teamScoreboardModal');
    if (modal) {
        modal.classList.remove('active');
    }
}

function updateScoreboardModal() {
    if (!currentTeam) return;
    
    // Update team name
    const modalTeamName = document.getElementById('modalTeamName');
    if (modalTeamName) {
        modalTeamName.textContent = currentTeam.teamName || currentTeam.name || 'Team Name';
    }
    
    // Update team stats
    const modalHolesCompleted = document.getElementById('modalHolesCompleted');
    if (modalHolesCompleted) {
        modalHolesCompleted.textContent = `${currentTeam.holesCompleted || 0}/12`;
    }
    
    // Generate scorecard table
    generateModalScorecard();
}

function generateModalScorecard() {
    if (!currentTeam || !currentTeam.players) return;
    
    const container = document.getElementById('modalScorecardContainer');
    if (!container) return;
    
    // Define hole order and names
    const holeOrder = ['Plinko', 'SpinningTop', 'Haphazard', 'Roundhouse', 'HillHop', 'SkiJump', 'Mastermind', 'Igloo', 'Octagon', 'LoopDeLoop', 'UpAndOver', 'Lopside'];
    const holeNames = {
        'Plinko': 'Plinko',
        'SpinningTop': 'Spinning Top',
        'Haphazard': 'Haphazard',
        'Roundhouse': 'Roundhouse',
        'HillHop': 'Hill Hop',
        'SkiJump': 'Ski Jump',
        'Mastermind': 'Mastermind',
        'Igloo': 'Igloo',
        'Octagon': 'Octagon',
        'LoopDeLoop': 'Loop De Loop',
        'UpAndOver': 'Up And Over',
        'Lopside': 'Lopside'
    };

    // Create table
    const table = document.createElement('table');
    table.className = 'scorecard-table';
    table.setAttribute('role', 'table');
    table.setAttribute('aria-describedby', 'modalTeamName');

    // Caption (visually hidden for accessibility)
    const caption = document.createElement('caption');
    caption.className = 'visually-hidden';
    caption.textContent = 'Per-player hole scores and totals';
    table.appendChild(caption);

    // Create header using DOM methods instead of innerHTML
    const thead = document.createElement('thead');
    const headerRow = document.createElement('tr');

    // Player name header
    const playerHeader = document.createElement('th');
    playerHeader.className = 'player-name-header';
    playerHeader.textContent = 'Player';
    headerRow.appendChild(playerHeader);

    // Hole headers
    holeOrder.forEach((holeId, index) => {
        const th = document.createElement('th');
        th.className = 'hole-header';
        th.textContent = holeNames[holeId] || holeId;
        headerRow.appendChild(th);
    });

    // Total header
    const totalHeader = document.createElement('th');
    totalHeader.className = 'total-header';
    totalHeader.textContent = 'Total';
    headerRow.appendChild(totalHeader);

    thead.appendChild(headerRow);
    table.appendChild(thead);

    // Create body rows
    const tbody = document.createElement('tbody');
    currentTeam.players.forEach(player => {
        let playerTotal = 0;
        const row = document.createElement('tr');

        // Player name cell
        const nameCell = document.createElement('th');
        nameCell.className = 'player-name-cell';
        nameCell.setAttribute('scope', 'row');
        nameCell.textContent = player.name;
        row.appendChild(nameCell);

        // Score cells
        holeOrder.forEach(holeId => {
            const score = player.scores && player.scores[holeId];
            const scoreValue = score ? score.total : '-';
            const scoreClass = score ? (score.total > 0 ? 'positive-score' : score.total < 0 ? 'negative-score' : 'zero-score') : 'no-score';

            const scoreCell = document.createElement('td');
            scoreCell.className = `score-cell ${scoreClass}`;
            scoreCell.textContent = scoreValue;
            scoreCell.dataset.holeId = holeId;
            row.appendChild(scoreCell);
        });

        // Total cell
        playerTotal = Object.values(player.scores).reduce((sum, holeScore) => sum + (holeScore.total || 0), 0);
        const totalClass = playerTotal > 0 ? 'positive-score' : playerTotal < 0 ? 'negative-score' : 'zero-score';
        const totalCell = document.createElement('td');
        totalCell.className = `total-cell ${totalClass}`;
        totalCell.textContent = playerTotal;
        row.appendChild(totalCell);

        tbody.appendChild(row);
    });

    table.appendChild(tbody);

    // Highlight best/worst per column (excluding '-' and zero baseline). Done after full table built.
    try {
        const bodyRows = Array.from(tbody.querySelectorAll('tr'));
        const holeCount = holeOrder.length;
        for (let colIndex = 0; colIndex < holeCount; colIndex++) {
            let values = [];
            bodyRows.forEach(r => {
                const cell = r.querySelectorAll('td,th')[colIndex+1]; // +1 offset due to name header th
                if (!cell || cell.classList.contains('total-cell')) return;
                const raw = cell.textContent.trim();
                const num = parseInt(raw, 10);
                if (!isNaN(num)) {
                    values.push({ num, cell });
                }
            });
            if (values.length) {
                const max = Math.max(...values.map(v => v.num));
                const min = Math.min(...values.map(v => v.num));
                values.forEach(v => {
                    if (v.num === max && max > 0) v.cell.classList.add('best-score');
                    if (v.num === min && min < 0) v.cell.classList.add('worst-score');
                });
            }
        }
    } catch (e) {
        console.warn('Highlighting failed', e);
    }
    // Replace existing table
    container.innerHTML = '';
    container.appendChild(table);
}

// Show/hide scoreboard button based on team status
function updateScoreboardButtonVisibility() {
    const button = document.getElementById('openScoreboardBtn');
    if (button && currentTeam) {
        button.style.display = 'block';
    } else if (button) {
        button.style.display = 'none';
    }
}

// Close modal on outside click
document.addEventListener('DOMContentLoaded', function() {
    const modal = document.getElementById('teamScoreboardModal');
    if (modal) {
        modal.addEventListener('click', function(e) {
            if (e.target === modal) {
                closeTeamScoreboard();
            }
        });
    }
    
    // Close modal on Escape key
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
            closeTeamScoreboard();
        }
        // Open modal with 'S' key (for Scoreboard) when a team is active
        if (e.key.toLowerCase() === 's' && currentTeam && !document.getElementById('teamScoreboardModal').classList.contains('active')) {
            openTeamScoreboard();
        }
    });
});

// RFID Card Reader Handler
// RFID readers type the card number and hit Enter, just like a keyboard
let rfidInput = '';
let rfidTimeout = null;

document.addEventListener('keydown', function(e) {
    // Only capture RFID input when in waiting state
    const currentState = getCurrentState();
    if (currentState !== 'waiting') {
        return;
    }
    
    // Handle RFID input (numbers, letters, and some special characters)
    if (e.key.match(/^[0-9A-Fa-f]$/)) {
        rfidInput += e.key;
        
        // Clear any existing timeout
        if (rfidTimeout) {
            clearTimeout(rfidTimeout);
        }
        
        // Set timeout to clear input if no Enter received (in case of partial scan)
        rfidTimeout = setTimeout(() => {
            console.log('üö® RFID input timeout, clearing buffer');
            rfidInput = '';
        }, 3000);
        
    } else if (e.key === 'Enter' && rfidInput) {
        // RFID scanners send Enter after the card data
        e.preventDefault(); // Prevent form submission if any
        
        // Clear timeout
        if (rfidTimeout) {
            clearTimeout(rfidTimeout);
        }
        
        console.log(`üì° RFID Card Detected: ${rfidInput}`);
        handleRFIDScan(rfidInput);
        rfidInput = ''; // Reset
        
    } else if (e.key === 'Escape') {
        // Allow manual clearing of input buffer
        if (rfidTimeout) {
            clearTimeout(rfidTimeout);
        }
        rfidInput = '';
        console.log('üîÑ RFID input buffer cleared');
    }
    
    // Test mode fallback (press "1" + Enter or "F" + Enter)
    if (e.key === '1' && !rfidInput) {
        rfidInput = '1';
    } else if (e.key.toLowerCase() === 'f' && !rfidInput) {
        rfidInput = '3744990468'; // Bruce & Sam's team - has real Firebase data
    } else if (e.key.toLowerCase() === 'd' && !rfidInput && currentTeam) {
        // Debug: manually trigger ball score display update
        console.log('üîß Debug: Manually triggering updateBallScoreDisplay()');
        updateBallScoreDisplay();
        return;
    }
});

// Handle RFID scan by sending to server
async function handleRFIDScan(rfidCode) {
    console.log(`üéØ Processing RFID: ${rfidCode}`);
    
    // Show loading state
    showLoadingState('Loading team...');
    
    // Special test mode
    if (rfidCode === '1') {
        console.log('üß™ Test mode: Loading test team');
        setTimeout(() => {
            simulateTestRFIDTap();
        }, 1000); // Show loading for a moment
        return;
    } else if (rfidCode === '3744990468') {
        console.log('üî• Firebase test mode: Loading real team from Firebase');
        showLoadingState('Loading real Firebase team...');
        // This will actually scan the real RFID card and get live Firebase data
    }
    
    try {
        // Send RFID tap to server
        const response = await fetch('/api/rfid/tap', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                rfid: rfidCode,
                holeId: window.holeData.name, // Use the hole name from server data
                picoId: `tablet-${window.holeData.number}` // Identify this tablet
            })
        });
        
        if (response.ok) {
            const result = await response.json();
            console.log('‚úÖ RFID tap sent to server:', result);
            
            // The server will send game-started event via socket.io if successful
            // Set a timeout in case no response comes back
            setTimeout(() => {
                const currentState = getCurrentState();
                if (currentState === 'waiting') {
                    resetRFIDPromptState();
                    showError('No team found for this card. Please register at the counter.');
                }
            }, 5000);
            
        } else {
            const error = await response.json();
            console.error('‚ùå RFID tap failed:', error);
            resetRFIDPromptState();
            showError('Failed to process card. Please try again.');
        }
        
    } catch (error) {
        console.error('‚ùå Network error:', error);
        resetRFIDPromptState();
        showError('Connection error. Please try again.');
    }
}

// Show error state
function showError(message) {
    updateStatus(message, 'error');
    resetRFIDPromptState();
    setTimeout(() => {
        if (getCurrentState() === 'waiting') {
            updateStatus('Waiting for Team', 'waiting');
        }
    }, 3000);
}

// Show loading state while processing RFID
function showLoadingState(message = 'Loading team...') {
    const rfidIcon = document.getElementById('rfidIcon');
    const loadingSpinner = document.getElementById('loadingSpinner');
    const promptTitle = document.getElementById('rfidPromptTitle');
    const promptMessage = document.getElementById('rfidPromptMessage');
    
    if (rfidIcon) rfidIcon.style.display = 'none';
    if (loadingSpinner) loadingSpinner.style.display = 'block';
    if (promptTitle) promptTitle.textContent = message;
    if (promptMessage) promptMessage.textContent = 'Please wait...';
    
    updateStatus(message, 'loading');
}

// Reset RFID prompt to default state
function resetRFIDPromptState() {
    const rfidIcon = document.getElementById('rfidIcon');
    const loadingSpinner = document.getElementById('loadingSpinner');
    const promptTitle = document.getElementById('rfidPromptTitle');
    const promptMessage = document.getElementById('rfidPromptMessage');
    
    if (rfidIcon) rfidIcon.style.display = 'block';
    if (loadingSpinner) loadingSpinner.style.display = 'none';
    if (promptTitle) promptTitle.textContent = 'Tap your team card to start';
    if (promptMessage) promptMessage.textContent = 'Hold your RFID card near the reader';
}

// Get current state helper function
function getCurrentState() {
    const activeState = document.querySelector('.game-state.active');
    if (activeState) {
        return activeState.id.replace('State', '');
    }
    return 'waiting';
}

// Show tap count indicator for visual feedback
function showTapCountIndicator(count) {
    // Remove any existing tap indicator
    const existingIndicator = document.getElementById('tap-count-indicator');
    if (existingIndicator) {
        existingIndicator.remove();
    }
    
    // Create new tap indicator
    const indicator = document.createElement('div');
    indicator.id = 'tap-count-indicator';
    indicator.textContent = `${count}/4`;
    indicator.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255, 255, 255, 0.9);
        color: #333;
        padding: 8px 16px;
        border-radius: 20px;
        font-size: 18px;
        font-weight: bold;
        z-index: 9999;
        pointer-events: none;
        animation: tapIndicatorPulse 0.3s ease-out;
    `;
    
    // Add animation keyframes if not already present
    if (!document.querySelector('#tap-indicator-styles')) {
        const style = document.createElement('style');
        style.id = 'tap-indicator-styles';
        style.textContent = `
            @keyframes tapIndicatorPulse {
                0% {
                    opacity: 0;
                    transform: translate(-50%, -50%) scale(0.5);
                }
                50% {
                    opacity: 1;
                    transform: translate(-50%, -50%) scale(1.1);
                }
                100% {
                    opacity: 1;
                    transform: translate(-50%, -50%) scale(1);
                }
            }
        `;
        document.head.appendChild(style);
    }
    
    document.body.appendChild(indicator);
    
    // Remove indicator after a short delay
    setTimeout(() => {
        if (indicator.parentNode) {
            indicator.remove();
        }
    }, 600);
}

// Simulate a test RFID tap for easy testing
function simulateTestRFIDTap() {
    // Create mock team data that would normally come from the server
    // This mimics real Firebase data structure with throws array
    const testTeam = {
        rfid: '1234567890',
        name: 'Test Team Alpha',
        teamName: 'Test Team Alpha',
        totalScore: 1850,
        holesCompleted: 8,
        players: [
            {
                id: 'alice@test.com',
                name: 'Alice',
                scores: {
                    'Plinko': { total: 200, throws: [100, 50, 50] },
                    'SpinningTop': { total: 150, throws: [75, 75] },
                    'Haphazard': { total: -50, throws: [-100, 50] },
                    'Roundhouse': { total: 100, throws: [50, 25, 25] },
                    'HillHop': { total: 175, throws: [100, 75] },
                    'SkiJump': { total: 75, throws: [75] },
                    'Mastermind': { total: 125, throws: [50, 50, 25] },
                    'Igloo': { total: 250, throws: [125, 125] }
                }
            },
            {
                id: 'bob@test.com',
                name: 'Bob',
                scores: {
                    'Plinko': { total: 150, throws: [100, 50] },
                    'SpinningTop': { total: 200, throws: [100, 100] },
                    'Haphazard': { total: 25, throws: [50, -25] },
                    'Roundhouse': { total: 175, throws: [100, 75] },
                    'HillHop': { total: 100, throws: [50, 50] },
                    'SkiJump': { total: -25, throws: [-25] },
                    'Mastermind': { total: 200, throws: [100, 100] },
                    'Igloo': { total: 0, throws: [25, -25] }
                }
            },
            {
                id: 'charlie@test.com',
                name: 'Charlie',
                scores: {
                    'Plinko': { total: 100, throws: [100] },
                    'SpinningTop': { total: 125, throws: [75, 50] },
                    'Haphazard': { total: 75, throws: [50, 25] },
                    'Roundhouse': { total: 50, throws: [50] },
                    'HillHop': { total: 200, throws: [100, 100] },
                    'SkiJump': { total: 150, throws: [150] },
                    'Mastermind': { total: 25, throws: [25] },
                    'Igloo': { total: 175, throws: [100, 75] }
                }
            }
        ]
    };
    
    // Simulate the server response that would normally happen
    currentTeam = testTeam;
    
    // Recalculate dynamic sizing before showing player display
    calculateAndSetDynamicSizes();
    
    // Show the current player in center with animation
    updateCurrentPlayerDisplay();
    const currentPlayerDisplay = document.querySelector('.current-player-display');
    if (currentPlayerDisplay) {
        currentPlayerDisplay.classList.add('show');
    }
    
    // Show other team players in bottom border with slide-up animation
    updateBottomPlayersDisplay();
    const bottomBorder = document.getElementById('bottomTeamBorder');
    if (bottomBorder) {
        bottomBorder.classList.add('show');
    }
    
    // Start with no indicators lit (Ball1 state)
    resetBallIndicators();
    
    // Update ball score indicators with current player's Plinko scores
    updateBallScoreDisplay();
    
    // Show scoreboard button
    updateScoreboardButtonVisibility();
    
    // Switch to playing state
    showState('playing');
    updateStatus(`${testTeam.name} Playing`, 'playing');
    
    console.log('üéÆ Test team loaded successfully!');
}

// Function to update ball score display next to ball indicators
function updateBallScoreDisplay() {
    console.log('üéØ === BALL SCORE DISPLAY DEBUG START ===');
    
    if (!currentTeam || !currentTeam.players || currentTeam.players.length === 0) {
        console.log('‚ùå No team or players available for ball score display');
        console.log('currentTeam:', currentTeam);
        return;
    }
    
    // Get the current hole name
    const holeNames = ['Plinko', 'SpinningTop', 'Haphazard', 'Roundhouse', 'HillHop', 'SkiJump', 'Mastermind', 'Igloo', 'Octagon', 'LoopDeLoop', 'UpAndOver', 'Lopside'];
    const currentHoleId = holeNames[holeNumber - 1];
    
    console.log(`üéØ Looking for ball scores on hole: ${currentHoleId} (hole ${holeNumber})`);
    console.log(`üéÆ Current team full data:`, JSON.stringify(currentTeam, null, 2));
    
    // Find the current active player (this could be determined by game state)
    // For now, we'll use the first player, but this should be dynamic based on whose turn it is
    let currentPlayer = null;
    
    // Check if we have players in the expected format (array)
    if (Array.isArray(currentTeam.players)) {
        currentPlayer = currentTeam.players[0];
        console.log(`üë§ Using array format - Current player:`, JSON.stringify(currentPlayer, null, 2));
    } 
    // Check if we have players in Firebase format (object with player IDs as keys)
    else if (typeof currentTeam.players === 'object') {
        const playerIds = Object.keys(currentTeam.players);
        console.log(`üîë Found ${playerIds.length} player IDs:`, playerIds);
        if (playerIds.length > 0) {
            const playerId = playerIds[0]; // Use first player for now
            currentPlayer = {
                id: playerId,
                name: currentTeam.players[playerId].displayName || playerId,
                // Convert Firebase scorePerHole format to our expected scores format
                scores: currentTeam.players[playerId].scorePerHole || {}
            };
            console.log(`üë§ Using Firebase format - Converted player:`, JSON.stringify(currentPlayer, null, 2));
            console.log(`üìä Raw Firebase player data:`, JSON.stringify(currentTeam.players[playerId], null, 2));
        }
    }
    
    if (!currentPlayer) {
        console.log('‚ùå No current player found');
        return;
    }
    
    // Get the throws for this hole from the player's scorePerHole data
    let throws = [];
    
    // Check if player has scores for the current hole
    if (currentPlayer.scores && currentPlayer.scores[currentHoleId]) {
        const holeData = currentPlayer.scores[currentHoleId];
        console.log(`üìä Raw hole data for ${currentHoleId}:`, JSON.stringify(holeData, null, 2));
        
        // Let's also check ALL the keys in holeData to see what's actually there
        console.log(`üîç All keys in holeData:`, Object.keys(holeData));
        console.log(`üîç holeData values:`, Object.values(holeData));
        
        // Check for weird labeling like -1, 0, 1 that you mentioned
        console.log(`üéØ Checking for numbered keys (-1, 0, 1, etc.):`);
        for (let i = -1; i <= 5; i++) {
            if (holeData[i] !== undefined) {
                console.log(`  Key "${i}": ${holeData[i]}`);
            }
        }
        
        // Handle different Firebase formats for throws
        if (holeData.throws && Array.isArray(holeData.throws)) {
            // Format: throws: [50, -50, 25]
            throws = holeData.throws;
            console.log('üì¶ Found throws array format:', throws);
        } else if (typeof holeData === 'object') {
            // Firebase format: throw1: 50, throw2: -50, throw3: 25
            const throwValues = [];
            for (let i = 1; i <= 3; i++) {
                const throwKey = `throw${i}`;
                console.log(`üîç Checking for ${throwKey}:`, holeData[throwKey]);
                if (holeData[throwKey] !== undefined && holeData[throwKey] !== null) {
                    throwValues.push(holeData[throwKey]);
                }
            }
            if (throwValues.length > 0) {
                throws = throwValues;
                console.log('üî• Found Firebase throw1/throw2/throw3 format:', throws);
            } else {
                // Maybe the scores are stored as numbered keys like -1, 0, 1?
                console.log('üîç Trying numbered keys like -1, 0, 1, 2...');
                const numberedThrows = [];
                for (let i = -1; i <= 5; i++) {
                    if (holeData[i] !== undefined && holeData[i] !== null) {
                        numberedThrows.push(holeData[i]);
                        console.log(`‚úÖ Found throw at key "${i}": ${holeData[i]}`);
                    }
                }
                if (numberedThrows.length > 0) {
                    throws = numberedThrows;
                    console.log('üî• Found numbered key format:', throws);
                } else {
                    console.log('‚ùå No throw1/throw2/throw3 values found');
                    console.log('üîç Available keys in holeData:', Object.keys(holeData));
                }
            }
        } else if (Array.isArray(holeData)) {
            // Direct array format
            throws = holeData;
            console.log('üìã Found direct array format:', throws);
        }
    } else {
        console.log(`‚ùå No score data found for hole ${currentHoleId}`);
        console.log(`üìä Available holes for player:`, currentPlayer.scores ? Object.keys(currentPlayer.scores) : 'No scores object');
    }
    
    console.log(`üéØ Final throws array for display:`, throws);
    
    // Check if we have any throw data at all
    const hasThrowData = throws.length > 0 && throws.some(t => t !== undefined && t !== null);
    
    if (!hasThrowData) {
        console.log('‚ö†Ô∏è No individual throw data available - hiding ball score display');
        // Hide the entire ball score display container when no throw data is available
        const ballScoreDisplay = document.querySelector('.ball-score-display');
        if (ballScoreDisplay) {
            ballScoreDisplay.style.display = 'none';
        }
        
        // Clear all ball score displays
        for (let i = 1; i <= 3; i++) {
            const ballScoreElement = document.getElementById(`ballScore${i}`);
            if (ballScoreElement) {
                ballScoreElement.textContent = '';
                ballScoreElement.classList.remove('visible', 'positive', 'negative', 'zero');
            }
        }
        
        console.log('üéØ === BALL SCORE DISPLAY DEBUG END (No Data) ===');
        return;
    }
    
    // Show the ball score display container since we have data
    const ballScoreDisplay = document.querySelector('.ball-score-display');
    if (ballScoreDisplay) {
        ballScoreDisplay.style.display = 'flex';
    }
    
    // Clear all ball score displays first
    for (let i = 1; i <= 3; i++) {
        const ballScoreElement = document.getElementById(`ballScore${i}`);
        if (ballScoreElement) {
            ballScoreElement.textContent = '';
            ballScoreElement.classList.remove('visible', 'positive', 'negative', 'zero');
            console.log(`üóëÔ∏è Cleared ball ${i} score element`);
        } else {
            console.log(`‚ùå Could not find ballScore${i} element`);
        }
    }
    
    // Update each ball score element with the throws
    for (let i = 1; i <= 3; i++) {
        const ballScoreElement = document.getElementById(`ballScore${i}`);
        if (!ballScoreElement) {
            console.log(`‚ùå Ball score element ${i} not found`);
            continue;
        }
        
        // If there's a score for this throw, display it
        if (throws[i - 1] !== undefined && throws[i - 1] !== null) {
            const score = throws[i - 1];
            
            // Set the score text with proper formatting
            ballScoreElement.textContent = score > 0 ? `+${score}` : `${score}`;
            
            // Add appropriate color class
            if (score > 0) {
                ballScoreElement.classList.add('positive');
            } else if (score < 0) {
                ballScoreElement.classList.add('negative');
            } else {
                ballScoreElement.classList.add('zero');
            }
            
            // Make it visible with animation
            ballScoreElement.classList.add('visible');
            
            console.log(`üèÄ Ball ${i} score: ${score} (formatted: ${ballScoreElement.textContent})`);
        } else {
            console.log(`üèÄ Ball ${i}: No throw data (throws[${i-1}] = ${throws[i - 1]})`);
        }
    }
    
    console.log('üéØ === BALL SCORE DISPLAY DEBUG END ===');
}
</script>

</body>
</html>
